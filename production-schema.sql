WARN: no SMS provider is enabled. Disabling phone login
Dumping schemas from remote database...
17.4.1.043: Pulling from supabase/postgres
9a405988f699: Pulling fs layer
e58177e9e1b5: Pulling fs layer
e3700d13feb7: Pulling fs layer
2acae2bbc1ca: Pulling fs layer
ef473adfec35: Pulling fs layer
033131c8cf2f: Pulling fs layer
80f4e9e4af12: Pulling fs layer
4f4fb700ef54: Pulling fs layer
13b7e930469f: Pulling fs layer
6c767cde8f0c: Pulling fs layer
4cb4b54acb13: Pulling fs layer
d39e2abd29e2: Pulling fs layer
d7428ff3fa38: Pulling fs layer
9a0d6dc67688: Pulling fs layer
2a826a242b18: Pulling fs layer
df409b313ac6: Pulling fs layer
cde0264d4d97: Pulling fs layer
1b2e90aaa0f6: Pulling fs layer
4f4fb700ef54: Pulling fs layer
559a946917af: Pulling fs layer
fe327af87b4d: Pulling fs layer
92266dfbc6e9: Pulling fs layer
3b1daf06a926: Pulling fs layer
b87ba44b0adb: Pulling fs layer
467f1a9b8171: Pulling fs layer
bdd485ba6a59: Pulling fs layer
050851e97c2a: Pulling fs layer
1cf0d7686d3e: Pulling fs layer
d37a9777b68c: Pulling fs layer
49152c6cc5d6: Pulling fs layer
f0d058a55412: Pulling fs layer
1f0a80387610: Pulling fs layer
db94b6c1628e: Pulling fs layer
4f4fb700ef54: Pulling fs layer
fe8768757809: Pulling fs layer
1faee1835a67: Pulling fs layer
57a8d44b7b7b: Pulling fs layer
6de0c5625e02: Pulling fs layer
8a45cddef0aa: Pulling fs layer
6f59c7a4c977: Pulling fs layer
de1035bdb2f5: Pulling fs layer
db2b77e9739c: Pulling fs layer
4b018d9c5ab9: Pulling fs layer
185ac0b6f562: Pulling fs layer
e111174a0ba7: Pulling fs layer
6c3913f6152c: Pulling fs layer
6c27164d937b: Pulling fs layer
5d4d89e8ef95: Pulling fs layer
440c5b7cccaf: Pulling fs layer
a375e419a70b: Pulling fs layer
40fd502164d6: Pulling fs layer
6c767cde8f0c: Download complete
ef473adfec35: Download complete
2a826a242b18: Download complete
9a405988f699: Download complete
e58177e9e1b5: Download complete
1f0a80387610: Download complete
40fd502164d6: Download complete
fe327af87b4d: Download complete
f0d058a55412: Download complete
4f4fb700ef54: Download complete
cde0264d4d97: Download complete
1cf0d7686d3e: Download complete
6c3913f6152c: Download complete
df409b313ac6: Download complete
e3700d13feb7: Download complete
033131c8cf2f: Download complete
49152c6cc5d6: Download complete
4cb4b54acb13: Download complete
8a45cddef0aa: Download complete
d39e2abd29e2: Download complete
d7428ff3fa38: Download complete
e111174a0ba7: Download complete
6c27164d937b: Download complete
6de0c5625e02: Download complete
440c5b7cccaf: Download complete
92266dfbc6e9: Download complete
a375e419a70b: Download complete
1faee1835a67: Download complete
6f59c7a4c977: Download complete
db94b6c1628e: Download complete
de1035bdb2f5: Download complete
185ac0b6f562: Download complete
57a8d44b7b7b: Download complete
559a946917af: Download complete
fe8768757809: Download complete
b87ba44b0adb: Download complete
050851e97c2a: Download complete
13b7e930469f: Download complete
9a0d6dc67688: Download complete
5d4d89e8ef95: Download complete
80f4e9e4af12: Download complete
d37a9777b68c: Download complete
13b7e930469f: Pull complete
4b018d9c5ab9: Download complete
1b2e90aaa0f6: Download complete
2acae2bbc1ca: Download complete
bdd485ba6a59: Download complete
49152c6cc5d6: Pull complete
050851e97c2a: Pull complete
bdd485ba6a59: Pull complete
db2b77e9739c: Download complete
3b1daf06a926: Download complete
3b1daf06a926: Pull complete
5d4d89e8ef95: Pull complete
467f1a9b8171: Download complete
467f1a9b8171: Pull complete
2a826a242b18: Pull complete
d7428ff3fa38: Pull complete
1b2e90aaa0f6: Pull complete
6c3913f6152c: Pull complete
8a45cddef0aa: Pull complete
6c27164d937b: Pull complete
9a405988f699: Pull complete
92266dfbc6e9: Pull complete
9a0d6dc67688: Pull complete
df409b313ac6: Pull complete
e111174a0ba7: Pull complete
80f4e9e4af12: Pull complete
db2b77e9739c: Pull complete
f0d058a55412: Pull complete
033131c8cf2f: Pull complete
d39e2abd29e2: Pull complete
4f4fb700ef54: Pull complete
fe8768757809: Pull complete
6de0c5625e02: Pull complete
2acae2bbc1ca: Pull complete
6c767cde8f0c: Pull complete
e58177e9e1b5: Pull complete
6f59c7a4c977: Pull complete
ef473adfec35: Pull complete
559a946917af: Pull complete
1f0a80387610: Pull complete
40fd502164d6: Pull complete
1cf0d7686d3e: Pull complete
a375e419a70b: Pull complete
440c5b7cccaf: Pull complete
185ac0b6f562: Pull complete
b87ba44b0adb: Pull complete
fe327af87b4d: Pull complete
e3700d13feb7: Pull complete
1faee1835a67: Pull complete
db94b6c1628e: Pull complete
4cb4b54acb13: Pull complete
57a8d44b7b7b: Pull complete
de1035bdb2f5: Pull complete
4b018d9c5ab9: Pull complete
cde0264d4d97: Pull complete
d37a9777b68c: Pull complete
Digest: sha256:3ef8870ab7f49fd9e67e4c1334fb4fec580b3c72ae7dbf3c3a19126ffaf2b033
Status: Downloaded newer image for public.ecr.aws/supabase/postgres:17.4.1.043


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "public";


ALTER SCHEMA "public" OWNER TO "pg_database_owner";


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE OR REPLACE FUNCTION "public"."admin_cancel_yield_posting"("p_date" "date") RETURNS TABLE("deleted_yield_records" integer, "deleted_profit_records" integer, "success" boolean, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_deleted_yield INTEGER := 0;
    v_deleted_profit INTEGER := 0;
BEGIN
    -- daily_yield_logから該当日のレコードを削除
    DELETE FROM daily_yield_log 
    WHERE date = p_date;
    
    GET DIAGNOSTICS v_deleted_yield = ROW_COUNT;
    
    -- user_daily_profitから該当日のレコードを削除
    DELETE FROM user_daily_profit 
    WHERE date = p_date;
    
    GET DIAGNOSTICS v_deleted_profit = ROW_COUNT;
    
    -- ログ記録
    INSERT INTO system_logs (
        log_type,
        operation,
        user_id,
        message,
        details,
        created_at
    ) VALUES (
        'SUCCESS',
        'admin_cancel_yield_posting',
        NULL,
        FORMAT('管理者が%sの日利設定をキャンセルしました', p_date),
        jsonb_build_object(
            'date', p_date,
            'deleted_yield_records', v_deleted_yield,
            'deleted_profit_records', v_deleted_profit
        ),
        NOW()
    );
    
    RETURN QUERY SELECT 
        v_deleted_yield,
        v_deleted_profit,
        true,
        FORMAT('削除完了: 日利設定%s件、利益記録%s件', v_deleted_yield, v_deleted_profit);

EXCEPTION
    WHEN OTHERS THEN
        -- エラーログ
        INSERT INTO system_logs (
            log_type,
            operation,
            user_id,
            message,
            details,
            created_at
        ) VALUES (
            'ERROR',
            'admin_cancel_yield_posting',
            NULL,
            FORMAT('日利キャンセルでエラー: %s', SQLERRM),
            jsonb_build_object(
                'date', p_date,
                'error_message', SQLERRM,
                'error_state', SQLSTATE
            ),
            NOW()
        );
        
        RETURN QUERY SELECT 
            0,
            0,
            false,
            FORMAT('エラー: %s', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."admin_cancel_yield_posting"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_cancel_yield_posting_v2"("p_date" "date") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_deleted_yield INTEGER := 0;
    v_deleted_profit INTEGER := 0;
    v_result JSONB;
BEGIN
    -- daily_yield_logから該当日のレコードを削除
    DELETE FROM daily_yield_log 
    WHERE date = p_date;
    
    GET DIAGNOSTICS v_deleted_yield = ROW_COUNT;
    
    -- user_daily_profitから該当日のレコードを削除
    DELETE FROM user_daily_profit 
    WHERE date = p_date;
    
    GET DIAGNOSTICS v_deleted_profit = ROW_COUNT;
    
    -- 結果をJSONBで返す
    v_result := jsonb_build_object(
        'success', true,
        'message', FORMAT('削除完了: 日利設定%s件、利益記録%s件', v_deleted_yield, v_deleted_profit),
        'deleted_yield_records', v_deleted_yield,
        'deleted_profit_records', v_deleted_profit,
        'date', p_date
    );
    
    -- ログ記録
    INSERT INTO system_logs (
        log_type,
        operation,
        user_id,
        message,
        details,
        created_at
    ) VALUES (
        'SUCCESS',
        'admin_cancel_yield_posting_v2',
        NULL,
        FORMAT('管理者が%sの日利設定をキャンセルしました', p_date),
        v_result,
        NOW()
    );
    
    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
        -- エラー時もJSONBで返す
        v_result := jsonb_build_object(
            'success', false,
            'message', FORMAT('エラー: %s', SQLERRM),
            'deleted_yield_records', 0,
            'deleted_profit_records', 0,
            'error_code', SQLSTATE
        );
        
        -- エラーログ
        INSERT INTO system_logs (
            log_type,
            operation,
            user_id,
            message,
            details,
            created_at
        ) VALUES (
            'ERROR',
            'admin_cancel_yield_posting_v2',
            NULL,
            FORMAT('日利キャンセルでエラー: %s', SQLERRM),
            v_result,
            NOW()
        );
        
        RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."admin_cancel_yield_posting_v2"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_check_affiliate_cycle_data"("p_admin_email" "text") RETURNS TABLE("user_id" "text", "phase" character varying, "total_nft_count" integer, "cum_usdt" numeric, "available_usdt" numeric, "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_admin_exists BOOLEAN;
BEGIN
  -- 管理者権限確認
  SELECT EXISTS(
    SELECT 1 FROM admins 
    WHERE email = p_admin_email AND is_active = true
  ) INTO v_admin_exists;

  IF NOT v_admin_exists THEN
    RAISE EXCEPTION '管理者権限がありません';
  END IF;

  -- affiliate_cycleテーブルの全データを取得
  RETURN QUERY 
  SELECT 
    ac.user_id,
    ac.phase,
    ac.total_nft_count,
    ac.cum_usdt,
    ac.available_usdt,
    ac.created_at,
    ac.updated_at
  FROM affiliate_cycle ac
  ORDER BY ac.cum_usdt DESC;

END;
$$;


ALTER FUNCTION "public"."admin_check_affiliate_cycle_data"("p_admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_clear_test_data"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    DELETE FROM test_affiliate_reward;
    DELETE FROM test_user_daily_profit;
    DELETE FROM test_company_daily_profit;
    DELETE FROM test_daily_yield_log;
    
    RETURN json_build_object(
        'success', true,
        'message', 'テストデータをすべてクリアしました'
    );
END;
$$;


ALTER FUNCTION "public"."admin_clear_test_data"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_clear_test_data"() IS 'テストデータのクリア関数';



CREATE OR REPLACE FUNCTION "public"."admin_generate_daily_profit_data"("p_admin_email" "text", "p_date" "date") RETURNS TABLE("status" "text", "affected_users" integer, "total_profit" numeric, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
  v_admin_exists BOOLEAN;
  v_yield_data RECORD;
  v_user_record RECORD;
  v_affected_count INTEGER := 0;
  v_total_profit NUMERIC := 0;
  v_daily_profit NUMERIC;
  v_base_amount NUMERIC;
BEGIN
  -- 管理者権限確認
  SELECT EXISTS(
    SELECT 1 FROM admins 
    WHERE email = p_admin_email AND is_active = true
  ) INTO v_admin_exists;

  IF NOT v_admin_exists THEN
    RETURN QUERY SELECT 
      'ERROR'::TEXT,
      0::INTEGER,
      0::NUMERIC,
      '管理者権限がありません'::TEXT;
    RETURN;
  END IF;

  -- 指定日の日利設定を取得
  SELECT date, yield_rate, margin_rate, user_rate
  INTO v_yield_data
  FROM daily_yield_log 
  WHERE date = p_date;

  IF NOT FOUND THEN
    RETURN QUERY SELECT 
      'ERROR'::TEXT,
      0::INTEGER,
      0::NUMERIC,
      FORMAT('指定日 %s の日利設定が見つかりません', p_date)::TEXT;
    RETURN;
  END IF;

  -- 既存のuser_daily_profitデータを削除（重複防止）
  DELETE FROM user_daily_profit WHERE date = p_date;

  -- affiliate_cycleの各ユーザーに対して利益を計算・挿入
  FOR v_user_record IN
    SELECT 
      user_id,
      total_nft_count,
      cum_usdt
    FROM affiliate_cycle 
    WHERE total_nft_count > 0
  LOOP
    -- 基準金額（NFT数 × 1100）
    v_base_amount := v_user_record.total_nft_count * 1100;
    
    -- 日利計算（基準金額 × ユーザー利率）
    v_daily_profit := v_base_amount * v_yield_data.user_rate;

    -- user_daily_profitテーブルに挿入
    INSERT INTO user_daily_profit (
      user_id,
      date,
      daily_profit,
      yield_rate,
      user_rate,
      base_amount,
      phase,
      created_at
    )
    VALUES (
      v_user_record.user_id,
      p_date,
      v_daily_profit,
      v_yield_data.yield_rate,
      v_yield_data.user_rate,
      v_base_amount,
      'USDT',
      NOW()
    );

    v_affected_count := v_affected_count + 1;
    v_total_profit := v_total_profit + v_daily_profit;
  END LOOP;

  -- 結果を返す
  RETURN QUERY SELECT 
    'SUCCESS'::TEXT,
    v_affected_count::INTEGER,
    v_total_profit::NUMERIC,
    FORMAT('✅ %s の利益データを生成: %s名のユーザーに総額$%s配布', 
           p_date, v_affected_count, ROUND(v_total_profit, 2))::TEXT;

EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT 
    'ERROR'::TEXT,
    0::INTEGER,
    0::NUMERIC,
    FORMAT('利益データ生成エラー: %s', SQLERRM)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."admin_generate_daily_profit_data"("p_admin_email" "text", "p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_get_migration_stats"("p_admin_email" "text") RETURNS TABLE("table_name" "text", "total_records" integer, "total_amount" numeric, "sample_data" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_admin_exists BOOLEAN;
BEGIN
  -- 管理者権限確認
  SELECT EXISTS(
    SELECT 1 FROM admins 
    WHERE email = p_admin_email AND is_active = true
  ) INTO v_admin_exists;

  IF NOT v_admin_exists THEN
    RAISE EXCEPTION '管理者権限がありません';
  END IF;

  -- affiliate_cycle統計
  RETURN QUERY 
  SELECT 
    'affiliate_cycle'::TEXT,
    COUNT(*)::INTEGER,
    SUM(ac.cum_usdt)::NUMERIC,
    jsonb_agg(
      jsonb_build_object(
        'user_id', ac.user_id,
        'nft_count', ac.total_nft_count,
        'amount', ac.cum_usdt
      )
    ) FILTER (WHERE ac.user_id IS NOT NULL)
  FROM affiliate_cycle ac;

  -- purchases統計（承認済み）
  RETURN QUERY 
  SELECT 
    'purchases_approved'::TEXT,
    COUNT(*)::INTEGER,
    SUM(p.amount_usd::NUMERIC)::NUMERIC,
    jsonb_agg(
      jsonb_build_object(
        'user_id', p.user_id,
        'nft_quantity', p.nft_quantity,
        'amount', p.amount_usd
      )
    ) FILTER (WHERE p.user_id IS NOT NULL)
  FROM purchases p
  WHERE p.admin_approved = true
  LIMIT 5;

END;
$$;


ALTER FUNCTION "public"."admin_get_migration_stats"("p_admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_migrate_purchases_to_affiliate_cycle"("p_admin_email" "text") RETURNS TABLE("status" "text", "migrated_users" integer, "total_nft_count" integer, "total_amount" numeric, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
  v_admin_exists BOOLEAN;
  v_migrated_count INTEGER := 0;
  v_total_nfts INTEGER := 0;
  v_total_amount NUMERIC := 0;
  v_user_record RECORD;
  v_cycle_start_date TIMESTAMPTZ;
  v_has_cycle_start_date BOOLEAN;
  v_has_last_updated BOOLEAN;
BEGIN
  -- 管理者権限確認
  SELECT EXISTS(
    SELECT 1 FROM admins 
    WHERE email = p_admin_email AND is_active = true
  ) INTO v_admin_exists;

  IF NOT v_admin_exists THEN
    RETURN QUERY SELECT 
      'ERROR'::TEXT,
      0::INTEGER,
      0::INTEGER,
      0::NUMERIC,
      '管理者権限がありません'::TEXT;
    RETURN;
  END IF;

  -- テーブル構造確認
  SELECT EXISTS(
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'affiliate_cycle' AND column_name = 'cycle_start_date'
  ) INTO v_has_cycle_start_date;

  SELECT EXISTS(
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'affiliate_cycle' AND column_name = 'last_updated'
  ) INTO v_has_last_updated;

  -- 承認済み購入データをユーザーごとに集計してaffiliate_cycleに挿入
  FOR v_user_record IN
    SELECT 
      p.user_id,
      SUM(p.nft_quantity) as total_nft_count,
      SUM(p.amount_usd::numeric) as cum_usdt,
      MIN(p.created_at) as first_purchase_date
    FROM purchases p
    WHERE 
      p.admin_approved = true
      AND p.user_id NOT IN (SELECT user_id FROM affiliate_cycle)
    GROUP BY p.user_id
    HAVING SUM(p.nft_quantity) > 0
  LOOP
    -- カラムの存在に応じて動的にINSERT
    IF v_has_cycle_start_date AND v_has_last_updated THEN
      INSERT INTO affiliate_cycle (
        user_id, phase, total_nft_count, cum_usdt, cycle_start_date, last_updated
      )
      VALUES (
        v_user_record.user_id, 'USDT', v_user_record.total_nft_count, 
        v_user_record.cum_usdt, v_user_record.first_purchase_date, NOW()
      );
    ELSIF v_has_cycle_start_date THEN
      INSERT INTO affiliate_cycle (
        user_id, phase, total_nft_count, cum_usdt, cycle_start_date
      )
      VALUES (
        v_user_record.user_id, 'USDT', v_user_record.total_nft_count, 
        v_user_record.cum_usdt, v_user_record.first_purchase_date
      );
    ELSIF v_has_last_updated THEN
      INSERT INTO affiliate_cycle (
        user_id, phase, total_nft_count, cum_usdt, last_updated
      )
      VALUES (
        v_user_record.user_id, 'USDT', v_user_record.total_nft_count, 
        v_user_record.cum_usdt, NOW()
      );
    ELSE
      -- 基本カラムのみ
      INSERT INTO affiliate_cycle (
        user_id, phase, total_nft_count, cum_usdt
      )
      VALUES (
        v_user_record.user_id, 'USDT', v_user_record.total_nft_count, 
        v_user_record.cum_usdt
      );
    END IF;

    v_migrated_count := v_migrated_count + 1;
    v_total_nfts := v_total_nfts + v_user_record.total_nft_count;
    v_total_amount := v_total_amount + v_user_record.cum_usdt;
  END LOOP;

  -- 結果を返す
  RETURN QUERY SELECT 
    'SUCCESS'::TEXT,
    v_migrated_count::INTEGER,
    v_total_nfts::INTEGER,
    v_total_amount::NUMERIC,
    FORMAT('✅ 移行完了: %s名のユーザーデータを移行しました（NFT総数: %s、総投資額: $%s）', 
           v_migrated_count, v_total_nfts, v_total_amount)::TEXT;

EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT 
    'ERROR'::TEXT,
    0::INTEGER,
    0::INTEGER,
    0::NUMERIC,
    FORMAT('移行エラー: %s', SQLERRM)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."admin_migrate_purchases_to_affiliate_cycle"("p_admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean DEFAULT false) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_rate DECIMAL(5,4);
    v_total_users INTEGER;
    v_total_base_amount DECIMAL(12,2);
    v_total_user_profit DECIMAL(12,2);
    v_total_company_profit DECIMAL(12,2);
    v_total_affiliate_profit DECIMAL(12,2);
    v_result JSON;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    -- ユーザー利率計算（修正版）
    -- 正しい計算式: (日利率 - マージン率) × 0.6
    v_user_rate := (p_yield_rate - p_margin_rate) * 0.6;
    
    -- 日利ログに記録
    INSERT INTO daily_yield_log (date, yield_rate, margin_rate, user_rate, is_month_end, created_by)
    VALUES (p_date, p_yield_rate, p_margin_rate, v_user_rate, p_is_month_end, auth.uid())
    ON CONFLICT (date) DO UPDATE SET
        yield_rate = p_yield_rate,
        margin_rate = p_margin_rate,
        user_rate = v_user_rate,
        is_month_end = p_is_month_end,
        created_by = auth.uid();
    
    -- ユーザー日利計算
    INSERT INTO user_daily_profit (user_id, date, yield_rate, user_rate, base_amount, daily_profit, phase)
    SELECT 
        ac.user_id,
        p_date,
        p_yield_rate,
        v_user_rate,
        ac.total_nft_count * 1100.00,
        (ac.total_nft_count * 1100.00) * v_user_rate,
        ac.phase
    FROM affiliate_cycle ac
    WHERE ac.total_nft_count > 0
    ON CONFLICT (user_id, date) DO UPDATE SET
        yield_rate = p_yield_rate,
        user_rate = v_user_rate,
        base_amount = (SELECT total_nft_count FROM affiliate_cycle WHERE user_id = user_daily_profit.user_id) * 1100.00,
        daily_profit = ((SELECT total_nft_count FROM affiliate_cycle WHERE user_id = user_daily_profit.user_id) * 1100.00) * v_user_rate,
        phase = (SELECT phase FROM affiliate_cycle WHERE user_id = user_daily_profit.user_id);
    
    -- 紹介報酬計算（3段階）修正版
    -- 実効利率ベースで計算: (日利率 - マージン率) × 基準額 × 各レベル報酬率
    -- Level 1 (25%)
    INSERT INTO affiliate_reward (user_id, referral_user_id, date, level, reward_rate, base_profit, reward_amount, phase)
    SELECT 
        u1.user_id,
        udp.user_id,
        p_date,
        1,
        0.250,
        udp.base_amount * (p_yield_rate - p_margin_rate), -- 実効利率ベースの基準額
        udp.base_amount * (p_yield_rate - p_margin_rate) * 0.250,
        (SELECT phase FROM affiliate_cycle WHERE user_id = u1.user_id)
    FROM user_daily_profit udp
    JOIN users u1 ON udp.user_id = u1.referrer_user_id
    WHERE udp.date = p_date
    ON CONFLICT (user_id, referral_user_id, date, level) DO UPDATE SET
        base_profit = EXCLUDED.base_profit,
        reward_amount = EXCLUDED.reward_amount,
        phase = EXCLUDED.phase;
    
    -- Level 2 (10%)
    INSERT INTO affiliate_reward (user_id, referral_user_id, date, level, reward_rate, base_profit, reward_amount, phase)
    SELECT 
        u2.user_id,
        udp.user_id,
        p_date,
        2,
        0.100,
        udp.base_amount * (p_yield_rate - p_margin_rate), -- 実効利率ベースの基準額
        udp.base_amount * (p_yield_rate - p_margin_rate) * 0.100,
        (SELECT phase FROM affiliate_cycle WHERE user_id = u2.user_id)
    FROM user_daily_profit udp
    JOIN users u1 ON udp.user_id = u1.referrer_user_id
    JOIN users u2 ON u1.user_id = u2.referrer_user_id
    WHERE udp.date = p_date
    ON CONFLICT (user_id, referral_user_id, date, level) DO UPDATE SET
        base_profit = EXCLUDED.base_profit,
        reward_amount = EXCLUDED.reward_amount,
        phase = EXCLUDED.phase;
    
    -- Level 3 (5%)
    INSERT INTO affiliate_reward (user_id, referral_user_id, date, level, reward_rate, base_profit, reward_amount, phase)
    SELECT 
        u3.user_id,
        udp.user_id,
        p_date,
        3,
        0.050,
        udp.base_amount * (p_yield_rate - p_margin_rate), -- 実効利率ベースの基準額
        udp.base_amount * (p_yield_rate - p_margin_rate) * 0.050,
        (SELECT phase FROM affiliate_cycle WHERE user_id = u3.user_id)
    FROM user_daily_profit udp
    JOIN users u1 ON udp.user_id = u1.referrer_user_id
    JOIN users u2 ON u1.user_id = u2.referrer_user_id
    JOIN users u3 ON u2.user_id = u3.referrer_user_id
    WHERE udp.date = p_date
    ON CONFLICT (user_id, referral_user_id, date, level) DO UPDATE SET
        base_profit = EXCLUDED.base_profit,
        reward_amount = EXCLUDED.reward_amount,
        phase = EXCLUDED.phase;
    
    -- 統計計算
    SELECT 
        COUNT(*),
        SUM(base_amount),
        SUM(daily_profit)
    INTO v_total_users, v_total_base_amount, v_total_user_profit
    FROM user_daily_profit
    WHERE date = p_date;
    
    -- アフィリエイト報酬総額を計算
    SELECT 
        COALESCE(SUM(reward_amount), 0)
    INTO v_total_affiliate_profit
    FROM affiliate_reward
    WHERE date = p_date;
    
    -- 会社利益計算（修正版）
    -- 会社マージン30% + 実効利率の残り10%（プール金）
    v_total_company_profit := v_total_base_amount * p_margin_rate + v_total_base_amount * (p_yield_rate - p_margin_rate) * 0.1;
    
    INSERT INTO company_daily_profit (date, total_user_profit, total_company_profit, margin_rate, total_base_amount, user_count)
    VALUES (p_date, v_total_user_profit, v_total_company_profit, p_margin_rate, v_total_base_amount, v_total_users)
    ON CONFLICT (date) DO UPDATE SET
        total_user_profit = v_total_user_profit,
        total_company_profit = v_total_company_profit,
        margin_rate = p_margin_rate,
        total_base_amount = v_total_base_amount,
        user_count = v_total_users;
    
    v_result := json_build_object(
        'success', true,
        'date', p_date,
        'yield_rate', p_yield_rate,
        'margin_rate', p_margin_rate,
        'user_rate', v_user_rate,
        'total_users', v_total_users,
        'total_user_profit', v_total_user_profit,
        'total_affiliate_profit', v_total_affiliate_profit,
        'total_company_profit', v_total_company_profit,
        'calculation_breakdown', json_build_object(
            'effective_rate', p_yield_rate - p_margin_rate,
            'user_portion', 0.6,
            'affiliate_portion', 0.3,
            'pool_portion', 0.1
        )
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) IS '修正済み日利投稿関数: (日利率 - マージン率) × 0.6 = ユーザー受取率';



CREATE OR REPLACE FUNCTION "public"."admin_post_yield_test_mode"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean DEFAULT false) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_rate DECIMAL(5,4);
    v_total_users INTEGER;
    v_total_base_amount DECIMAL(12,2);
    v_total_user_profit DECIMAL(12,2);
    v_total_company_profit DECIMAL(12,2);
    v_total_affiliate_profit DECIMAL(12,2);
    v_result JSON;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    -- ユーザー利率計算（修正版）
    v_user_rate := (p_yield_rate - p_margin_rate) * 0.6;
    
    -- テストモード: 実際の計算結果を返すが、データベースには保存しない
    SELECT 
        COUNT(*),
        SUM(ac.total_nft_count * 1100.00),
        SUM(ac.total_nft_count * 1100.00 * v_user_rate)
    INTO v_total_users, v_total_base_amount, v_total_user_profit
    FROM affiliate_cycle ac
    WHERE ac.total_nft_count > 0;
    
    -- アフィリエイト報酬総額を計算
    v_total_affiliate_profit := v_total_base_amount * (p_yield_rate - p_margin_rate) * 0.3;
    
    -- 会社利益計算
    v_total_company_profit := v_total_base_amount * p_margin_rate + v_total_base_amount * (p_yield_rate - p_margin_rate) * 0.1;
    
    v_result := json_build_object(
        'success', true,
        'test_mode', true,
        'date', p_date,
        'yield_rate', p_yield_rate,
        'margin_rate', p_margin_rate,
        'user_rate', v_user_rate,
        'total_users', v_total_users,
        'total_user_profit', v_total_user_profit,
        'total_affiliate_profit', v_total_affiliate_profit,
        'total_company_profit', v_total_company_profit,
        'calculation_breakdown', json_build_object(
            'effective_rate', p_yield_rate - p_margin_rate,
            'user_portion', 0.6,
            'affiliate_portion', 0.3,
            'pool_portion', 0.1
        )
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."admin_post_yield_test_mode"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_post_yield_test_mode"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) IS '修正済みテストモード関数: 実際にデータベースに保存しない';



CREATE OR REPLACE FUNCTION "public"."admin_test_yield_calculation"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean DEFAULT false) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_rate DECIMAL(5,4);
    v_total_users INTEGER;
    v_total_base_amount DECIMAL(12,2);
    v_total_user_profit DECIMAL(12,2);
    v_total_company_profit DECIMAL(12,2);
    v_total_affiliate_profit DECIMAL(12,2);
    v_result JSON;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    -- ユーザー利率計算（修正版）
    v_user_rate := (p_yield_rate - p_margin_rate) * 0.6;
    
    -- テスト用テーブルに記録
    INSERT INTO test_daily_yield_log (date, yield_rate, margin_rate, user_rate, is_month_end, created_by)
    VALUES (p_date, p_yield_rate, p_margin_rate, v_user_rate, p_is_month_end, auth.uid())
    ON CONFLICT (date) DO UPDATE SET
        yield_rate = p_yield_rate,
        margin_rate = p_margin_rate,
        user_rate = v_user_rate,
        is_month_end = p_is_month_end,
        created_by = auth.uid();
    
    -- テスト用ユーザー日利計算（既存のaffiliate_cycleデータを参照するが、テスト用テーブルに保存）
    INSERT INTO test_user_daily_profit (user_id, date, yield_rate, user_rate, base_amount, daily_profit, phase)
    SELECT 
        ac.user_id,
        p_date,
        p_yield_rate,
        v_user_rate,
        ac.total_nft_count * 1100.00,
        (ac.total_nft_count * 1100.00) * v_user_rate,
        ac.phase
    FROM affiliate_cycle ac
    WHERE ac.total_nft_count > 0
    ON CONFLICT (user_id, date) DO UPDATE SET
        yield_rate = p_yield_rate,
        user_rate = v_user_rate,
        base_amount = EXCLUDED.base_amount,
        daily_profit = EXCLUDED.daily_profit,
        phase = EXCLUDED.phase;
    
    -- テスト用紹介報酬計算
    -- Level 1
    INSERT INTO test_affiliate_reward (user_id, referral_user_id, date, level, reward_rate, base_profit, reward_amount, phase)
    SELECT 
        u1.user_id,
        tudp.user_id,
        p_date,
        1,
        0.250,
        tudp.base_amount * (p_yield_rate - p_margin_rate),
        tudp.base_amount * (p_yield_rate - p_margin_rate) * 0.250,
        COALESCE((SELECT phase FROM affiliate_cycle WHERE user_id = u1.user_id), 'USDT')
    FROM test_user_daily_profit tudp
    JOIN users u1 ON tudp.user_id = u1.referrer_user_id
    WHERE tudp.date = p_date
    ON CONFLICT (user_id, referral_user_id, date, level) DO UPDATE SET
        base_profit = EXCLUDED.base_profit,
        reward_amount = EXCLUDED.reward_amount;
    
    -- Level 2 & 3も同様に実装...
    
    -- 統計計算
    SELECT 
        COUNT(*),
        SUM(base_amount),
        SUM(daily_profit)
    INTO v_total_users, v_total_base_amount, v_total_user_profit
    FROM test_user_daily_profit
    WHERE date = p_date;
    
    -- テスト用アフィリエイト報酬総額
    SELECT 
        COALESCE(SUM(reward_amount), 0)
    INTO v_total_affiliate_profit
    FROM test_affiliate_reward
    WHERE date = p_date;
    
    -- テスト用会社利益
    v_total_company_profit := v_total_base_amount * p_margin_rate + v_total_base_amount * (p_yield_rate - p_margin_rate) * 0.1;
    
    INSERT INTO test_company_daily_profit (date, total_user_profit, total_company_profit, margin_rate, total_base_amount, user_count)
    VALUES (p_date, v_total_user_profit, v_total_company_profit, p_margin_rate, v_total_base_amount, v_total_users)
    ON CONFLICT (date) DO UPDATE SET
        total_user_profit = v_total_user_profit,
        total_company_profit = v_total_company_profit,
        margin_rate = p_margin_rate,
        total_base_amount = v_total_base_amount,
        user_count = v_total_users;
    
    v_result := json_build_object(
        'success', true,
        'test_mode', true,
        'message', 'テスト実行完了 - 本番データには影響しません',
        'date', p_date,
        'yield_rate', p_yield_rate,
        'margin_rate', p_margin_rate,
        'user_rate', v_user_rate,
        'total_users', v_total_users,
        'total_user_profit', v_total_user_profit,
        'total_affiliate_profit', v_total_affiliate_profit,
        'total_company_profit', v_total_company_profit,
        'calculation_breakdown', json_build_object(
            'effective_rate', p_yield_rate - p_margin_rate,
            'user_portion', 0.6,
            'affiliate_portion', 0.3,
            'pool_portion', 0.1
        )
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."admin_test_yield_calculation"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."admin_test_yield_calculation"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) IS '本番データに影響しない安全なテスト実行関数';



CREATE OR REPLACE FUNCTION "public"."approve_nft_purchase_safe"("p_purchase_id" "uuid", "p_admin_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id VARCHAR(6);
    v_nft_quantity INTEGER;
    v_amount_usd DECIMAL;
    v_already_approved BOOLEAN;
BEGIN
    -- 既に承認済みかチェック
    SELECT admin_approved, user_id, nft_quantity, amount_usd
    INTO v_already_approved, v_user_id, v_nft_quantity, v_amount_usd
    FROM purchases
    WHERE id = p_purchase_id;
    
    -- 既に承認済みなら何もしない
    IF v_already_approved THEN
        RAISE NOTICE 'Purchase % is already approved', p_purchase_id;
        RETURN FALSE;
    END IF;
    
    -- トランザクション開始
    BEGIN
        -- 購入を承認
        UPDATE purchases 
        SET admin_approved = true,
            approved_at = NOW(),
            approved_by = p_admin_user_id
        WHERE id = p_purchase_id
        AND admin_approved = false;  -- 二重防止
        
        -- 影響を受けた行がない場合は既に処理済み
        IF NOT FOUND THEN
            RETURN FALSE;
        END IF;
        
        -- ユーザーのNFT状態を更新（実際の購入数に基づいて）
        UPDATE users u
        SET has_approved_nft = true,
            total_purchases = (
                SELECT COALESCE(SUM(amount_usd), 0)
                FROM purchases
                WHERE user_id = v_user_id
                AND admin_approved = true
            )
        WHERE user_id = v_user_id;
        
        -- affiliate_cycleを更新（実際の購入数に基づいて）
        UPDATE affiliate_cycle ac
        SET total_nft_count = (
                SELECT COALESCE(SUM(nft_quantity), 0)
                FROM purchases
                WHERE user_id = v_user_id
                AND admin_approved = true
            ),
            manual_nft_count = (
                SELECT COALESCE(SUM(nft_quantity), 0)
                FROM purchases
                WHERE user_id = v_user_id
                AND admin_approved = true
            )
        WHERE user_id = v_user_id;
        
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXCEPTION 'Error approving purchase: %', SQLERRM;
            RETURN FALSE;
    END;
END;
$$;


ALTER FUNCTION "public"."approve_nft_purchase_safe"("p_purchase_id" "uuid", "p_admin_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."approve_user_nft"("p_purchase_id" "text", "p_admin_email" "text", "p_admin_notes" "text" DEFAULT NULL::"text") RETURNS TABLE("status" "text", "message" "text", "user_id" "text", "nft_count" integer, "success" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_purchase RECORD;
    v_user_exists BOOLEAN;
    v_next_sequence INTEGER;
    v_nft_created INTEGER := 0;
    v_target_user_id TEXT;
    v_existing_manual_count INTEGER;
    v_existing_total_count INTEGER;
BEGIN
    -- 購入レコードを取得
    SELECT
        p.id,
        p.user_id,
        p.nft_quantity,
        p.amount_usd,
        p.admin_approved,
        p.is_auto_purchase
    INTO v_purchase
    FROM purchases p
    WHERE p.id::TEXT = p_purchase_id;

    IF NOT FOUND THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            '購入レコードが見つかりません'::TEXT,
            NULL::TEXT,
            0::INTEGER,
            false::BOOLEAN;
        RETURN;
    END IF;

    v_target_user_id := v_purchase.user_id;

    IF v_purchase.admin_approved THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            'この購入は既に承認済みです'::TEXT,
            v_target_user_id,
            0::INTEGER,
            false::BOOLEAN;
        RETURN;
    END IF;

    IF v_purchase.is_auto_purchase THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            '自動購入は手動承認できません'::TEXT,
            v_target_user_id,
            0::INTEGER,
            false::BOOLEAN;
        RETURN;
    END IF;

    SELECT EXISTS(SELECT 1 FROM users u WHERE u.user_id = v_target_user_id)
    INTO v_user_exists;

    IF NOT v_user_exists THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            'ユーザーが見つかりません'::TEXT,
            v_target_user_id,
            0::INTEGER,
            false::BOOLEAN;
        RETURN;
    END IF;

    -- nft_masterテーブルにNFTレコードを作成
    SELECT COALESCE(MAX(nm.nft_sequence), 0) + 1
    INTO v_next_sequence
    FROM nft_master nm
    WHERE nm.user_id = v_target_user_id;

    FOR i IN 1..v_purchase.nft_quantity LOOP
        INSERT INTO nft_master (
            user_id,
            nft_sequence,
            nft_type,
            nft_value,
            acquired_date,
            created_at,
            updated_at
        )
        VALUES (
            v_target_user_id,
            v_next_sequence + i - 1,
            'manual',
            1000.00,
            NOW()::DATE,
            NOW(),
            NOW()
        );
        v_nft_created := v_nft_created + 1;
    END LOOP;

    UPDATE purchases
    SET
        admin_approved = true,
        admin_approved_at = NOW(),
        admin_approved_by = p_admin_email,
        admin_notes = COALESCE(p_admin_notes, '承認済み'),
        payment_status = 'completed'
    WHERE id::TEXT = p_purchase_id;

    UPDATE users u
    SET
        total_purchases = u.total_purchases + v_purchase.amount_usd,
        updated_at = NOW()
    WHERE u.user_id = v_target_user_id;

    -- ★★★ affiliate_cycleを条件分岐で処理 ★★★
    SELECT manual_nft_count, total_nft_count
    INTO v_existing_manual_count, v_existing_total_count
    FROM affiliate_cycle
    WHERE affiliate_cycle.user_id = v_target_user_id;

    IF FOUND THEN
        -- 既存レコードがある場合は更新
        UPDATE affiliate_cycle
        SET
            manual_nft_count = manual_nft_count + v_purchase.nft_quantity,
            total_nft_count = total_nft_count + v_purchase.nft_quantity,
            last_updated = NOW()
        WHERE affiliate_cycle.user_id = v_target_user_id;
    ELSE
        -- 新規レコードを挿入
        INSERT INTO affiliate_cycle (
            user_id,
            manual_nft_count,
            auto_nft_count,
            total_nft_count,
            cum_usdt,
            available_usdt,
            phase,
            cycle_number,
            created_at,
            last_updated
        )
        VALUES (
            v_target_user_id,
            v_purchase.nft_quantity,
            0,
            v_purchase.nft_quantity,
            0,
            0,
            'USDT',
            1,
            NOW(),
            NOW()
        );
    END IF;

    RETURN QUERY SELECT
        'SUCCESS'::TEXT,
        FORMAT('購入を承認しました（NFT %s枚をnft_masterに作成）', v_nft_created)::TEXT,
        v_target_user_id,
        v_nft_created::INTEGER,
        true::BOOLEAN;

EXCEPTION WHEN OTHERS THEN
    RETURN QUERY SELECT
        'ERROR'::TEXT,
        FORMAT('エラーが発生しました: %s', SQLERRM)::TEXT,
        NULL::TEXT,
        0::INTEGER,
        false::BOOLEAN;
END;
$$;


ALTER FUNCTION "public"."approve_user_nft"("p_purchase_id" "text", "p_admin_email" "text", "p_admin_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_fix_nft_discrepancies"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_fixed_count INTEGER := 0;
    v_user RECORD;
BEGIN
    -- 不整合のあるユーザーを修正
    FOR v_user IN 
        SELECT * FROM nft_count_audit 
        WHERE status = 'DISCREPANCY'
    LOOP
        -- usersテーブルを修正
        UPDATE users 
        SET total_purchases = v_user.actual_amount
        WHERE user_id = v_user.user_id;
        
        -- affiliate_cycleテーブルを修正
        UPDATE affiliate_cycle 
        SET total_nft_count = v_user.actual_nft,
            manual_nft_count = v_user.actual_nft
        WHERE user_id = v_user.user_id;
        
        v_fixed_count := v_fixed_count + 1;
        
        RAISE NOTICE 'Fixed user %: % -> %', 
            v_user.user_id, 
            v_user.recorded_amount, 
            v_user.actual_amount;
    END LOOP;
    
    RETURN v_fixed_count;
END;
$$;


ALTER FUNCTION "public"."auto_fix_nft_discrepancies"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_and_distribute_referral_bonuses"("p_user_id" "text", "p_personal_profit" numeric, "p_date" "date") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_level1_referrer TEXT;
    v_level2_referrer TEXT;
    v_level3_referrer TEXT;
    v_level1_bonus NUMERIC;
    v_level2_bonus NUMERIC;
    v_level3_bonus NUMERIC;
BEGIN
    -- Level1紹介者（直接紹介者）を取得
    SELECT referrer_user_id INTO v_level1_referrer
    FROM users 
    WHERE user_id = p_user_id;
    
    -- Level1報酬計算・配布（20%）
    IF v_level1_referrer IS NOT NULL THEN
        v_level1_bonus := p_personal_profit * 0.20;
        
        -- Level1紹介者の利益に追加
        UPDATE user_daily_profit 
        SET referral_profit = COALESCE(referral_profit, 0) + v_level1_bonus,
            daily_profit = COALESCE(daily_profit, 0) + v_level1_bonus
        WHERE user_id = v_level1_referrer 
        AND date = p_date;
        
        -- Level1紹介者の record が存在しない場合は作成
        IF NOT FOUND THEN
            INSERT INTO user_daily_profit (
                user_id, date, daily_profit, referral_profit, 
                personal_profit, yield_rate, user_rate, base_amount, phase
            ) VALUES (
                v_level1_referrer, p_date, v_level1_bonus, v_level1_bonus,
                0, 0, 0, 0, 'REFERRAL'
            );
        END IF;
        
        -- Level2紹介者を取得
        SELECT referrer_user_id INTO v_level2_referrer
        FROM users 
        WHERE user_id = v_level1_referrer;
        
        -- Level2報酬計算・配布（10%）
        IF v_level2_referrer IS NOT NULL THEN
            v_level2_bonus := p_personal_profit * 0.10;
            
            UPDATE user_daily_profit 
            SET referral_profit = COALESCE(referral_profit, 0) + v_level2_bonus,
                daily_profit = COALESCE(daily_profit, 0) + v_level2_bonus
            WHERE user_id = v_level2_referrer 
            AND date = p_date;
            
            IF NOT FOUND THEN
                INSERT INTO user_daily_profit (
                    user_id, date, daily_profit, referral_profit, 
                    personal_profit, yield_rate, user_rate, base_amount, phase
                ) VALUES (
                    v_level2_referrer, p_date, v_level2_bonus, v_level2_bonus,
                    0, 0, 0, 0, 'REFERRAL'
                );
            END IF;
            
            -- Level3紹介者を取得
            SELECT referrer_user_id INTO v_level3_referrer
            FROM users 
            WHERE user_id = v_level2_referrer;
            
            -- Level3報酬計算・配布（5%）
            IF v_level3_referrer IS NOT NULL THEN
                v_level3_bonus := p_personal_profit * 0.05;
                
                UPDATE user_daily_profit 
                SET referral_profit = COALESCE(referral_profit, 0) + v_level3_bonus,
                    daily_profit = COALESCE(daily_profit, 0) + v_level3_bonus
                WHERE user_id = v_level3_referrer 
                AND date = p_date;
                
                IF NOT FOUND THEN
                    INSERT INTO user_daily_profit (
                        user_id, date, daily_profit, referral_profit, 
                        personal_profit, yield_rate, user_rate, base_amount, phase
                    ) VALUES (
                        v_level3_referrer, p_date, v_level3_bonus, v_level3_bonus,
                        0, 0, 0, 0, 'REFERRAL'
                    );
                END IF;
            END IF;
        END IF;
    END IF;
END;
$$;


ALTER FUNCTION "public"."calculate_and_distribute_referral_bonuses"("p_user_id" "text", "p_personal_profit" numeric, "p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_buyback_preview"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer) RETURNS TABLE("manual_buyback_amount" numeric, "auto_buyback_amount" numeric, "total_buyback_amount" numeric, "nft_count_manual" integer, "nft_count_auto" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_manual_buyback DECIMAL(10,2) := 0;
    v_auto_buyback DECIMAL(10,2) := 0;
    v_nft_record RECORD;
    v_nft_buyback DECIMAL(10,2);
    v_count_manual INTEGER := 0;
    v_count_auto INTEGER := 0;
BEGIN
    -- 手動NFTの買い取り金額計算（古い順に選択）
    FOR v_nft_record IN
        SELECT id, nft_sequence
        FROM nft_master
        WHERE user_id = p_user_id
          AND nft_type = 'manual'
          AND buyback_date IS NULL
        ORDER BY nft_sequence ASC
        LIMIT p_manual_nft_count
    LOOP
        v_nft_buyback := calculate_nft_buyback_amount(v_nft_record.id);
        v_manual_buyback := v_manual_buyback + v_nft_buyback;
        v_count_manual := v_count_manual + 1;
    END LOOP;

    -- 自動NFTの買い取り金額計算（古い順に選択）
    FOR v_nft_record IN
        SELECT id, nft_sequence
        FROM nft_master
        WHERE user_id = p_user_id
          AND nft_type = 'auto'
          AND buyback_date IS NULL
        ORDER BY nft_sequence ASC
        LIMIT p_auto_nft_count
    LOOP
        v_nft_buyback := calculate_nft_buyback_amount(v_nft_record.id);
        v_auto_buyback := v_auto_buyback + v_nft_buyback;
        v_count_auto := v_count_auto + 1;
    END LOOP;

    RETURN QUERY SELECT
        v_manual_buyback,
        v_auto_buyback,
        v_manual_buyback + v_auto_buyback,
        v_count_manual,
        v_count_auto;
END;
$$;


ALTER FUNCTION "public"."calculate_buyback_preview"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_daily_profit_with_purchase_date_check"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean DEFAULT true) RETURNS TABLE("status" "text", "message" "text", "processed_users" integer, "total_profit" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_processed_users INTEGER := 0;
    v_total_profit NUMERIC := 0;
    v_user_record RECORD;
    v_user_rate NUMERIC;
    v_daily_profit NUMERIC;
    v_base_amount NUMERIC;
    v_latest_purchase_date DATE;
BEGIN
    -- ユーザーごとに処理
    FOR v_user_record IN
        SELECT 
            ac.user_id,
            ac.total_nft_count,
            ac.phase
        FROM affiliate_cycle ac
        WHERE ac.total_nft_count > 0
    LOOP
        -- 最新の承認済み購入日を取得
        SELECT MAX(admin_approved_at::date) INTO v_latest_purchase_date
        FROM purchases 
        WHERE user_id = v_user_record.user_id 
        AND admin_approved = true;
        
        -- 🔥 購入後15日経過チェック
        IF v_latest_purchase_date IS NULL OR v_latest_purchase_date + INTERVAL '14 days' >= p_date THEN
            CONTINUE; -- スキップ
        END IF;
        
        -- 利率計算
        v_user_rate := (p_yield_rate * (100 - p_margin_rate) / 100) * 0.6;
        
        -- 運用額計算（NFT数 × 1000ドル）
        v_base_amount := v_user_record.total_nft_count * 1000;
        
        -- 日利計算
        v_daily_profit := v_base_amount * v_user_rate / 100;
        
        -- テストモードでない場合のみ実際に記録
        IF NOT p_is_test_mode THEN
            INSERT INTO user_daily_profit (
                user_id,
                date,
                daily_profit,
                yield_rate,
                user_rate,
                base_amount,
                phase,
                created_at
            ) VALUES (
                v_user_record.user_id,
                p_date,
                v_daily_profit,
                p_yield_rate,
                v_user_rate,
                v_base_amount,
                v_user_record.phase,
                NOW()
            );
        END IF;
        
        v_processed_users := v_processed_users + 1;
        v_total_profit := v_total_profit + v_daily_profit;
    END LOOP;
    
    RETURN QUERY SELECT 
        'SUCCESS'::TEXT,
        FORMAT('15日後開始ルールで%s名に日利配布完了', v_processed_users)::TEXT,
        v_processed_users,
        v_total_profit;
END;
$$;


ALTER FUNCTION "public"."calculate_daily_profit_with_purchase_date_check"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_daily_referral_rewards"("p_user_id" character varying, "p_date" "date") RETURNS TABLE("referral_user_id" character varying, "referral_level" integer, "referral_profit" numeric, "referral_amount" numeric, "calculation_date" "date")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_level1_rate NUMERIC := 0.20;  -- 20%
    v_level2_rate NUMERIC := 0.10;  -- 10%
    v_level3_rate NUMERIC := 0.05;  -- 5%
BEGIN
    -- Level 1: 直接紹介者
    RETURN QUERY
    WITH level1_users AS (
        SELECT u.user_id
        FROM users u
        WHERE u.referrer_user_id = p_user_id
          AND u.has_approved_nft = true
          AND u.operation_start_date IS NOT NULL
          AND u.operation_start_date <= p_date  -- ⭐ 運用開始日チェック
    ),
    level1_profits AS (
        SELECT
            l1.user_id,
            COALESCE(SUM(ndp.daily_profit), 0) as daily_profit
        FROM level1_users l1
        LEFT JOIN nft_daily_profit ndp ON ndp.user_id = l1.user_id AND ndp.date = p_date
        GROUP BY l1.user_id
    )
    SELECT
        lp.user_id::VARCHAR(6) as referral_user_id,
        1::INTEGER as referral_level,
        lp.daily_profit::NUMERIC as referral_profit,
        (lp.daily_profit * v_level1_rate)::NUMERIC as referral_amount,
        p_date::DATE as calculation_date
    FROM level1_profits lp
    WHERE lp.daily_profit > 0;

    -- Level 2: 間接紹介者（Level 1の紹介者）
    RETURN QUERY
    WITH level1_users AS (
        SELECT u.user_id
        FROM users u
        WHERE u.referrer_user_id = p_user_id
          AND u.has_approved_nft = true
    ),
    level2_users AS (
        SELECT u.user_id
        FROM users u
        INNER JOIN level1_users l1 ON u.referrer_user_id = l1.user_id
        WHERE u.has_approved_nft = true
          AND u.operation_start_date IS NOT NULL
          AND u.operation_start_date <= p_date  -- ⭐ 運用開始日チェック
    ),
    level2_profits AS (
        SELECT
            l2.user_id,
            COALESCE(SUM(ndp.daily_profit), 0) as daily_profit
        FROM level2_users l2
        LEFT JOIN nft_daily_profit ndp ON ndp.user_id = l2.user_id AND ndp.date = p_date
        GROUP BY l2.user_id
    )
    SELECT
        lp.user_id::VARCHAR(6) as referral_user_id,
        2::INTEGER as referral_level,
        lp.daily_profit::NUMERIC as referral_profit,
        (lp.daily_profit * v_level2_rate)::NUMERIC as referral_amount,
        p_date::DATE as calculation_date
    FROM level2_profits lp
    WHERE lp.daily_profit > 0;

    -- Level 3: 間接紹介者（Level 2の紹介者）
    RETURN QUERY
    WITH level1_users AS (
        SELECT u.user_id
        FROM users u
        WHERE u.referrer_user_id = p_user_id
          AND u.has_approved_nft = true
    ),
    level2_users AS (
        SELECT u.user_id
        FROM users u
        INNER JOIN level1_users l1 ON u.referrer_user_id = l1.user_id
        WHERE u.has_approved_nft = true
    ),
    level3_users AS (
        SELECT u.user_id
        FROM users u
        INNER JOIN level2_users l2 ON u.referrer_user_id = l2.user_id
        WHERE u.has_approved_nft = true
          AND u.operation_start_date IS NOT NULL
          AND u.operation_start_date <= p_date  -- ⭐ 運用開始日チェック
    ),
    level3_profits AS (
        SELECT
            l3.user_id,
            COALESCE(SUM(ndp.daily_profit), 0) as daily_profit
        FROM level3_users l3
        LEFT JOIN nft_daily_profit ndp ON ndp.user_id = l3.user_id AND ndp.date = p_date
        GROUP BY l3.user_id
    )
    SELECT
        lp.user_id::VARCHAR(6) as referral_user_id,
        3::INTEGER as referral_level,
        lp.daily_profit::NUMERIC as referral_profit,
        (lp.daily_profit * v_level3_rate)::NUMERIC as referral_amount,
        p_date::DATE as calculation_date
    FROM level3_profits lp
    WHERE lp.daily_profit > 0;

    RETURN;
END;
$$;


ALTER FUNCTION "public"."calculate_daily_referral_rewards"("p_user_id" character varying, "p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_monthly_rewards"("p_year" integer, "p_month" integer) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_result JSON;
    v_total_users INTEGER;
    v_total_rewards DECIMAL(12,2);
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    -- 月次報酬を計算して保存
    INSERT INTO user_monthly_rewards (user_id, year, month, total_daily_profit, total_referral_rewards, total_rewards)
    SELECT 
        udp.user_id,
        p_year,
        p_month,
        COALESCE(SUM(udp.daily_profit), 0) as total_daily_profit,
        COALESCE(SUM(ar.reward_amount), 0) as total_referral_rewards,
        COALESCE(SUM(udp.daily_profit), 0) + COALESCE(SUM(ar.reward_amount), 0) as total_rewards
    FROM user_daily_profit udp
    LEFT JOIN affiliate_reward ar ON udp.user_id = ar.user_id AND udp.date = ar.date
    WHERE EXTRACT(YEAR FROM udp.date) = p_year 
      AND EXTRACT(MONTH FROM udp.date) = p_month
    GROUP BY udp.user_id
    ON CONFLICT (user_id, year, month) DO UPDATE SET
        total_daily_profit = EXCLUDED.total_daily_profit,
        total_referral_rewards = EXCLUDED.total_referral_rewards,
        total_rewards = EXCLUDED.total_rewards,
        updated_at = NOW();
    
    -- 結果統計
    SELECT 
        COUNT(*),
        SUM(total_rewards)
    INTO v_total_users, v_total_rewards
    FROM user_monthly_rewards
    WHERE year = p_year AND month = p_month;
    
    v_result := json_build_object(
        'success', true,
        'year', p_year,
        'month', p_month,
        'total_users', v_total_users,
        'total_rewards', v_total_rewards
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."calculate_monthly_rewards"("p_year" integer, "p_month" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_monthly_rewards"("p_year" integer, "p_month" integer) IS '月次報酬集計関数';



CREATE OR REPLACE FUNCTION "public"."calculate_nft_buyback_amount"("p_nft_id" "uuid") RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_nft_type TEXT;
    v_base_value DECIMAL(10,2);
    v_total_profit DECIMAL(10,3);
    v_buyback_amount DECIMAL(10,2);
BEGIN
    -- NFT情報を取得（個人収益のみを使用）
    SELECT nft_type, nft_value, total_profit_for_buyback
    INTO v_nft_type, v_base_value, v_total_profit
    FROM nft_total_profit
    WHERE nft_id = p_nft_id;

    -- 買い取り基本額を決定
    IF v_nft_type = 'manual' THEN
        v_base_value := 1000; -- 手動購入NFTは1000ドル
    ELSE
        v_base_value := 500;  -- 自動購入/付与NFTは500ドル
    END IF;

    -- 買い取り額 = 基本額 - (個人収益累計 ÷ 2)
    -- 注: 紹介報酬は含めない
    v_buyback_amount := v_base_value - (v_total_profit / 2);

    -- 0以下にはならない
    IF v_buyback_amount < 0 THEN
        v_buyback_amount := 0;
    END IF;

    RETURN v_buyback_amount;
END;
$$;


ALTER FUNCTION "public"."calculate_nft_buyback_amount"("p_nft_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_nft_buyback_amount"("p_nft_id" "uuid") IS 'NFT1個の買い取り金額を計算';



CREATE OR REPLACE FUNCTION "public"."calculate_operation_start_date"("p_approved_at" timestamp with time zone) RETURNS "date"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
    v_approved_date DATE;
    v_day_of_month INTEGER;
    v_operation_start_date DATE;
BEGIN
    -- 承認日（日本時間）を取得
    v_approved_date := (p_approved_at AT TIME ZONE 'Asia/Tokyo')::DATE;
    v_day_of_month := EXTRACT(DAY FROM v_approved_date);

    -- 運用開始日を計算
    IF v_day_of_month <= 5 THEN
        -- ① 5日までに購入：当月15日より運用開始
        v_operation_start_date := DATE_TRUNC('month', v_approved_date)::DATE + INTERVAL '14 days';
    ELSIF v_day_of_month <= 20 THEN
        -- ② 6日～20日に購入：翌月1日より運用開始
        v_operation_start_date := (DATE_TRUNC('month', v_approved_date) + INTERVAL '1 month')::DATE;
    ELSE
        -- ③ 21日～月末に購入：翌月15日より運用開始
        v_operation_start_date := (DATE_TRUNC('month', v_approved_date) + INTERVAL '1 month')::DATE + INTERVAL '14 days';
    END IF;

    RETURN v_operation_start_date;
END;
$$;


ALTER FUNCTION "public"."calculate_operation_start_date"("p_approved_at" timestamp with time zone) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_referral_rewards_with_dormant"("p_date" "date", "p_is_test_mode" boolean DEFAULT false) RETURNS TABLE("status" "text", "total_users" integer, "total_rewards" numeric, "company_bonus_from_dormant" numeric, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
    v_user_record RECORD;
    v_referrer_record RECORD;
    v_user_count INTEGER := 0;
    v_total_rewards DECIMAL(10,3) := 0;
    v_company_bonus DECIMAL(10,3) := 0;
    v_user_daily_profit DECIMAL(10,3);
    v_level INTEGER;
    v_referrer_id TEXT;
    v_reward_amount DECIMAL(10,3);
    v_reward_rate DECIMAL(5,4);
    v_is_dormant BOOLEAN;
    v_referrer_email TEXT;
    v_current_user_id TEXT;
BEGIN
    -- 各ユーザーの日次利益を取得
    FOR v_user_record IN
        SELECT
            udp.user_id,
            udp.daily_profit,
            u.referrer_user_id
        FROM user_daily_profit udp
        INNER JOIN users u ON udp.user_id = u.user_id
        WHERE udp.date = p_date
          AND udp.daily_profit > 0  -- プラス利益のみ
    LOOP
        v_user_daily_profit := v_user_record.daily_profit;
        v_current_user_id := v_user_record.user_id;
        v_level := 0;

        -- 最大3レベルまで遡る
        WHILE v_level < 3 AND v_current_user_id IS NOT NULL LOOP
            -- 上位の紹介者を取得
            SELECT
                u.user_id,
                u.email,
                u.is_active_investor,
                u.referrer_user_id
            INTO v_referrer_record
            FROM users u
            WHERE u.user_id = (
                SELECT referrer_user_id
                FROM users
                WHERE user_id = v_current_user_id
            );

            -- 紹介者が存在しない場合は終了
            EXIT WHEN v_referrer_record.user_id IS NULL;

            v_level := v_level + 1;

            -- レベルに応じた報酬率
            v_reward_rate := CASE v_level
                WHEN 1 THEN 0.10  -- Level 1: 10%
                WHEN 2 THEN 0.05  -- Level 2: 5%
                WHEN 3 THEN 0.03  -- Level 3: 3%
                ELSE 0
            END;

            v_reward_amount := v_user_daily_profit * v_reward_rate;

            -- ★★★ 重要：休眠ユーザーかチェック ★★★
            v_is_dormant := NOT COALESCE(v_referrer_record.is_active_investor, FALSE);

            IF NOT p_is_test_mode THEN
                IF v_is_dormant THEN
                    -- 休眠ユーザー → 会社アカウント（7A9637）へ報酬
                    INSERT INTO user_referral_profit (
                        user_id,
                        date,
                        referral_level,
                        child_user_id,
                        profit_amount,
                        created_at
                    )
                    VALUES (
                        '7A9637',  -- 会社アカウント
                        p_date,
                        v_level,
                        v_user_record.user_id,
                        v_reward_amount,
                        NOW()
                    );

                    -- 会社ボーナステーブルに記録
                    INSERT INTO company_bonus_from_dormant (
                        date,
                        dormant_user_id,
                        dormant_user_email,
                        child_user_id,
                        referral_level,
                        original_amount,
                        company_user_id
                    )
                    VALUES (
                        p_date,
                        v_referrer_record.user_id,
                        v_referrer_record.email,
                        v_user_record.user_id,
                        v_level,
                        v_reward_amount,
                        '7A9637'
                    );

                    v_company_bonus := v_company_bonus + v_reward_amount;

                ELSE
                    -- アクティブユーザー → 通常通り紹介者へ報酬
                    INSERT INTO user_referral_profit (
                        user_id,
                        date,
                        referral_level,
                        child_user_id,
                        profit_amount,
                        created_at
                    )
                    VALUES (
                        v_referrer_record.user_id,
                        p_date,
                        v_level,
                        v_user_record.user_id,
                        v_reward_amount,
                        NOW()
                    );
                END IF;

                v_total_rewards := v_total_rewards + v_reward_amount;
            END IF;

            -- 次のレベルへ
            v_current_user_id := v_referrer_record.referrer_user_id;
        END LOOP;

        v_user_count := v_user_count + 1;
    END LOOP;

    -- 結果を返す
    RETURN QUERY SELECT
        CASE WHEN p_is_test_mode THEN 'TEST_SUCCESS' ELSE 'SUCCESS' END::TEXT,
        v_user_count::INTEGER,
        v_total_rewards::DECIMAL(10,3),
        v_company_bonus::DECIMAL(10,3),
        FORMAT('%s完了: %s名処理, 総報酬: $%s, 会社ボーナス: $%s',
               CASE WHEN p_is_test_mode THEN 'テスト' ELSE '本番' END,
               v_user_count, v_total_rewards, v_company_bonus)::TEXT;

EXCEPTION WHEN OTHERS THEN
    RETURN QUERY SELECT
        'ERROR'::TEXT,
        0::INTEGER,
        0::DECIMAL(10,3),
        0::DECIMAL(10,3),
        FORMAT('エラー: %s', SQLERRM)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."calculate_referral_rewards_with_dormant"("p_date" "date", "p_is_test_mode" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_user_all_nft_buyback"("p_user_id" "text", "p_nft_type" "text" DEFAULT NULL::"text") RETURNS TABLE("nft_count" integer, "total_profit" numeric, "total_buyback_amount" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::INTEGER as nft_count,
        SUM(ntp.total_profit) as total_profit,
        SUM(calculate_nft_buyback_amount(ntp.nft_id)) as total_buyback_amount
    FROM nft_total_profit ntp
    WHERE ntp.user_id = p_user_id
        AND ntp.buyback_date IS NULL -- 保有中のみ
        AND (p_nft_type IS NULL OR ntp.nft_type = p_nft_type);
END;
$$;


ALTER FUNCTION "public"."calculate_user_all_nft_buyback"("p_user_id" "text", "p_nft_type" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_user_all_nft_buyback"("p_user_id" "text", "p_nft_type" "text") IS 'ユーザーの全NFTまたは指定タイプのNFT買い取り金額を計算';



CREATE OR REPLACE FUNCTION "public"."cancel_yield_posting"("p_date" "date") RETURNS TABLE("deleted_yield_records" integer, "deleted_profit_records" integer, "success" boolean, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- admin_cancel_yield_postingを呼び出すだけ
    RETURN QUERY SELECT * FROM admin_cancel_yield_posting(p_date);
END;
$$;


ALTER FUNCTION "public"."cancel_yield_posting"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."change_user_referrer"("target_user_id" character varying, "new_referrer_id" character varying, "admin_email" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    result JSON;
    referrer_exists BOOLEAN;
BEGIN
    -- 管理者権限確認
    IF NOT EXISTS (SELECT 1 FROM admins WHERE email = admin_email) THEN
        RETURN json_build_object('success', false, 'message', '管理者権限がありません');
    END IF;
    
    -- 対象ユーザー存在確認
    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = target_user_id) THEN
        RETURN json_build_object('success', false, 'message', '対象ユーザーが見つかりません');
    END IF;
    
    -- 新しい紹介者が空でない場合の確認
    IF new_referrer_id IS NOT NULL AND new_referrer_id != '' THEN
        -- 紹介者存在確認
        SELECT EXISTS (SELECT 1 FROM users WHERE user_id = new_referrer_id) INTO referrer_exists;
        IF NOT referrer_exists THEN
            RETURN json_build_object('success', false, 'message', '指定された紹介者が見つかりません');
        END IF;
        
        -- 自己参照チェック
        IF target_user_id = new_referrer_id THEN
            RETURN json_build_object('success', false, 'message', '自分自身を紹介者に設定することはできません');
        END IF;
    END IF;
    
    -- 紹介者更新
    UPDATE users 
    SET referrer_user_id = CASE 
        WHEN new_referrer_id = '' THEN NULL 
        ELSE new_referrer_id 
    END,
    updated_at = NOW()
    WHERE user_id = target_user_id;
    
    RETURN json_build_object(
        'success', true, 
        'message', '紹介者を更新しました',
        'target_user', target_user_id,
        'new_referrer', new_referrer_id
    );
    
EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object('success', false, 'message', 'エラー: ' || SQLERRM);
END;
$$;


ALTER FUNCTION "public"."change_user_referrer"("target_user_id" character varying, "new_referrer_id" character varying, "admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_cycle_status"() RETURNS TABLE("status" "text", "user_count" bigint, "details" "text")
    LANGUAGE "plpgsql"
    AS $_$
BEGIN
    -- cum_usdtが2200以上のユーザー
    RETURN QUERY
    SELECT 
        'cum_usdt >= 2200'::TEXT,
        COUNT(*),
        string_agg(user_id || '($' || ROUND(cum_usdt, 2) || ')', ', ')::TEXT
    FROM affiliate_cycle
    WHERE cum_usdt >= 2200;
    
    -- cum_usdtが1100以上2200未満のユーザー
    RETURN QUERY
    SELECT 
        '1100 <= cum_usdt < 2200'::TEXT,
        COUNT(*),
        string_agg(user_id || '($' || ROUND(cum_usdt, 2) || ')', ', ')::TEXT
    FROM affiliate_cycle
    WHERE cum_usdt >= 1100 AND cum_usdt < 2200;
    
    -- available_usdtが100以上のユーザー
    RETURN QUERY
    SELECT 
        'available_usdt >= 100'::TEXT,
        COUNT(*),
        string_agg(user_id || '($' || ROUND(available_usdt, 2) || ')', ', ')::TEXT
    FROM affiliate_cycle
    WHERE available_usdt >= 100;
    
    -- 全体の統計
    RETURN QUERY
    SELECT 
        '全ユーザー統計'::TEXT,
        COUNT(*),
        ('平均cum_usdt: $' || ROUND(AVG(cum_usdt), 2) || ', 平均available_usdt: $' || ROUND(AVG(available_usdt), 2))::TEXT
    FROM affiliate_cycle
    WHERE total_nft_count > 0;
END;
$_$;


ALTER FUNCTION "public"."check_cycle_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_max_referral_level"("target_user_id" "text") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    max_level integer;
BEGIN
    WITH RECURSIVE referral_check AS (
        SELECT 
            user_id,
            1 as level_num
        FROM users
        WHERE referrer_user_id = target_user_id
        
        UNION ALL
        
        SELECT 
            u.user_id,
            rc.level_num + 1
        FROM users u
        INNER JOIN referral_check rc ON u.referrer_user_id = rc.user_id
        WHERE rc.level_num < 100
    )
    SELECT COALESCE(MAX(level_num), 0) INTO max_level FROM referral_check;
    
    RETURN max_level;
END;
$$;


ALTER FUNCTION "public"."check_max_referral_level"("target_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_monthly_withdrawal_candidates"() RETURNS TABLE("category" "text", "user_count" bigint, "total_amount" numeric, "details" "text")
    LANGUAGE "plpgsql"
    AS $_$
BEGIN
    -- NFT購入対象者
    RETURN QUERY
    SELECT 
        'NFT自動購入対象'::TEXT,
        COUNT(*),
        SUM(FLOOR(cum_usdt / 2200) * 2200),
        ('平均cum_usdt: $' || ROUND(AVG(cum_usdt), 2))::TEXT
    FROM affiliate_cycle
    WHERE cum_usdt >= 2200;
    
    -- 出金対象者（NFT購入前）
    RETURN QUERY
    SELECT 
        '出金対象（現在）'::TEXT,
        COUNT(*),
        SUM(available_usdt),
        ('平均available_usdt: $' || ROUND(AVG(available_usdt), 2))::TEXT
    FROM affiliate_cycle
    WHERE available_usdt >= 100;
    
    -- 出金対象者（NFT購入後の予測）
    RETURN QUERY
    WITH after_nft AS (
        SELECT 
            user_id,
            CASE 
                WHEN cum_usdt >= 2200 THEN available_usdt + (FLOOR(cum_usdt / 2200) * 1100)
                ELSE available_usdt
            END as new_available_usdt
        FROM affiliate_cycle
    )
    SELECT 
        '出金対象（NFT購入後）'::TEXT,
        COUNT(*),
        SUM(new_available_usdt),
        ('平均available_usdt: $' || ROUND(AVG(new_available_usdt), 2))::TEXT
    FROM after_nft
    WHERE new_available_usdt >= 100;
END;
$_$;


ALTER FUNCTION "public"."check_monthly_withdrawal_candidates"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_nft_discrepancies"() RETURNS TABLE("user_id" character varying, "email" "text", "discrepancy_type" "text", "expected_value" numeric, "actual_value" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        na.user_id,
        na.email,
        CASE 
            WHEN na.amount_diff != 0 THEN 'AMOUNT_MISMATCH'
            WHEN na.nft_diff != 0 THEN 'NFT_COUNT_MISMATCH'
        END::TEXT as discrepancy_type,
        na.actual_amount as expected_value,
        na.recorded_amount as actual_value
    FROM nft_count_audit na
    WHERE na.status = 'DISCREPANCY';
END;
$$;


ALTER FUNCTION "public"."check_nft_discrepancies"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_nft_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_actual_nft INTEGER;
BEGIN
    -- 実際の購入NFT数を取得
    SELECT COALESCE(SUM(nft_quantity), 0)
    INTO v_actual_nft
    FROM purchases
    WHERE user_id = NEW.user_id
    AND admin_approved = true;
    
    -- 不整合を検知
    IF NEW.total_nft_count > v_actual_nft THEN
        RAISE WARNING 'NFT count mismatch detected for user %: recorded=%, actual=%',
            NEW.user_id, NEW.total_nft_count, v_actual_nft;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_nft_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_yield_posting_impact"("p_date" "date") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
    v_result JSON;
    v_user_count INTEGER;
    v_total_profit DECIMAL(12,2);
    v_total_affiliate DECIMAL(12,2);
    v_is_recent BOOLEAN;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    -- 日利投稿の存在確認
    IF NOT EXISTS (SELECT 1 FROM daily_yield_log WHERE date = p_date) THEN
        RAISE EXCEPTION '指定日の日利投稿が見つかりません: %', p_date;
    END IF;
    
    -- 影響するユーザー数と利益額を計算
    SELECT 
        COUNT(*),
        COALESCE(SUM(daily_profit), 0)
    INTO v_user_count, v_total_profit
    FROM user_daily_profit
    WHERE date = p_date;
    
    -- 紹介報酬総額を計算
    SELECT 
        COALESCE(SUM(reward_amount), 0)
    INTO v_total_affiliate
    FROM affiliate_reward
    WHERE date = p_date;
    
    -- 最近の投稿かどうか判定（7日以内）
    v_is_recent := (p_date >= CURRENT_DATE - INTERVAL '7 days');
    
    v_result := json_build_object(
        'date', p_date,
        'can_cancel', v_is_recent,
        'affected_users', v_user_count,
        'total_user_profit', v_total_profit,
        'total_affiliate_rewards', v_total_affiliate,
        'warning_message', CASE 
            WHEN NOT v_is_recent THEN '7日以上前の投稿は取消できません'
            WHEN v_user_count > 0 THEN format('%s名のユーザーの利益 $%s が削除されます', v_user_count, v_total_profit)
            ELSE 'この投稿による利益配布はありません'
        END
    );
    
    RETURN v_result;
END;
$_$;


ALTER FUNCTION "public"."check_yield_posting_impact"("p_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_yield_posting_impact"("p_date" "date") IS '日利投稿の影響を確認（削除前チェック用）';



CREATE OR REPLACE FUNCTION "public"."complete_reward_task"("p_user_id" character varying, "p_answers" "jsonb") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_current_year INTEGER;
    v_current_month INTEGER;
    v_task_exists BOOLEAN;
    v_withdrawal_month DATE;
BEGIN
    -- 現在の年月を取得（日本時間）
    v_current_year := EXTRACT(YEAR FROM (NOW() AT TIME ZONE 'Asia/Tokyo'));
    v_current_month := EXTRACT(MONTH FROM (NOW() AT TIME ZONE 'Asia/Tokyo'));
    v_withdrawal_month := DATE(v_current_year || '-' || LPAD(v_current_month::TEXT, 2, '0') || '-01');

    -- タスクレコードの存在確認
    SELECT EXISTS(
        SELECT 1 FROM monthly_reward_tasks
        WHERE user_id = p_user_id
        AND year = v_current_year
        AND month = v_current_month
    ) INTO v_task_exists;

    IF NOT v_task_exists THEN
        -- タスクレコードが存在しない場合は作成
        INSERT INTO monthly_reward_tasks (
            user_id, year, month, is_completed, questions_answered, answers, completed_at
        )
        VALUES (
            p_user_id, v_current_year, v_current_month, true,
            jsonb_array_length(p_answers), p_answers, NOW()
        );
    ELSE
        -- 既存のタスクを完了状態に更新
        UPDATE monthly_reward_tasks
        SET
            is_completed = true,
            questions_answered = jsonb_array_length(p_answers),
            answers = p_answers,
            completed_at = NOW(),
            updated_at = NOW()
        WHERE user_id = p_user_id
        AND year = v_current_year
        AND month = v_current_month;
    END IF;

    -- 対応する出金レコードを更新
    -- ⭐ task_completed = true に変更
    -- ⭐ status を 'pending'（送金待ち）に変更
    UPDATE monthly_withdrawals
    SET
        task_completed = true,
        task_completed_at = NOW(),
        status = CASE
            WHEN withdrawal_method IS NOT NULL THEN 'pending'  -- 送金方法設定済み → 送金待ち
            ELSE 'on_hold'  -- 送金方法未設定 → 保留継続
        END,
        updated_at = NOW()
    WHERE user_id = p_user_id
    AND withdrawal_month = v_withdrawal_month;

    RETURN true;
END;
$$;


ALTER FUNCTION "public"."complete_reward_task"("p_user_id" character varying, "p_answers" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."complete_withdrawal"("p_withdrawal_id" integer) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id VARCHAR(6);
    v_amount NUMERIC;
    v_current_available NUMERIC;
BEGIN
    -- 出金レコードを取得
    SELECT user_id, total_amount
    INTO v_user_id, v_amount
    FROM monthly_withdrawals
    WHERE id = p_withdrawal_id
      AND status IN ('pending', 'on_hold');

    IF v_user_id IS NULL THEN
        RAISE EXCEPTION '出金レコードが見つかりません、または既に完了済みです';
    END IF;

    -- 現在の available_usdt を取得
    SELECT available_usdt
    INTO v_current_available
    FROM affiliate_cycle
    WHERE user_id = v_user_id;

    IF v_current_available IS NULL THEN
        RAISE EXCEPTION 'ユーザーの affiliate_cycle レコードが見つかりません';
    END IF;

    -- available_usdt から出金額を減算（0未満にならないように）
    UPDATE affiliate_cycle
    SET
        available_usdt = GREATEST(0, available_usdt - v_amount),
        last_updated = NOW()
    WHERE user_id = v_user_id;

    -- 出金レコードを完了済みに更新
    UPDATE monthly_withdrawals
    SET
        status = 'completed',
        completed_at = NOW(),
        updated_at = NOW()
    WHERE id = p_withdrawal_id;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."complete_withdrawal"("p_withdrawal_id" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."complete_withdrawals_batch"("p_withdrawal_ids" integer[]) RETURNS TABLE("withdrawal_id" integer, "user_id" character varying, "amount" numeric, "success" boolean, "error_message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_withdrawal_id INTEGER;
BEGIN
    FOREACH v_withdrawal_id IN ARRAY p_withdrawal_ids
    LOOP
        BEGIN
            -- 各出金を完了処理
            DECLARE
                v_user_id VARCHAR(6);
                v_amount NUMERIC;
            BEGIN
                SELECT mw.user_id, mw.total_amount
                INTO v_user_id, v_amount
                FROM monthly_withdrawals mw
                WHERE mw.id = v_withdrawal_id
                  AND mw.status IN ('pending', 'on_hold');

                IF v_user_id IS NULL THEN
                    RETURN QUERY SELECT
                        v_withdrawal_id,
                        NULL::VARCHAR(6),
                        0::NUMERIC,
                        FALSE,
                        '出金レコードが見つかりません'::TEXT;
                    CONTINUE;
                END IF;

                -- available_usdt から出金額を減算
                UPDATE affiliate_cycle
                SET
                    available_usdt = GREATEST(0, available_usdt - v_amount),
                    last_updated = NOW()
                WHERE user_id = v_user_id;

                -- 出金レコードを完了済みに更新
                UPDATE monthly_withdrawals
                SET
                    status = 'completed',
                    completed_at = NOW(),
                    updated_at = NOW()
                WHERE id = v_withdrawal_id;

                RETURN QUERY SELECT
                    v_withdrawal_id,
                    v_user_id,
                    v_amount,
                    TRUE,
                    ''::TEXT;
            END;
        EXCEPTION WHEN OTHERS THEN
            RETURN QUERY SELECT
                v_withdrawal_id,
                NULL::VARCHAR(6),
                0::NUMERIC,
                FALSE,
                SQLERRM::TEXT;
        END;
    END LOOP;
END;
$$;


ALTER FUNCTION "public"."complete_withdrawals_batch"("p_withdrawal_ids" integer[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_buyback_request"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer, "p_wallet_address" "text", "p_wallet_type" "text") RETURNS TABLE("request_id" "uuid", "status" "text", "message" "text", "manual_buyback_amount" numeric, "auto_buyback_amount" numeric, "total_buyback_amount" numeric, "success" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
DECLARE
    v_request_id UUID;
    v_manual_buyback DECIMAL(10,2) := 0;
    v_auto_buyback DECIMAL(10,2) := 0;
    v_total_buyback DECIMAL(10,2) := 0;
    v_available_manual INTEGER := 0;
    v_available_auto INTEGER := 0;
    v_nft_record RECORD;
    v_nft_buyback DECIMAL(10,2);
BEGIN
    -- 入力値検証
    IF p_manual_nft_count < 0 OR p_auto_nft_count < 0 THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '無効な NFT 数が指定されました'::TEXT,
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            false::BOOLEAN;
        RETURN;
    END IF;

    IF p_manual_nft_count = 0 AND p_auto_nft_count = 0 THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '買い取りするNFTを選択してください'::TEXT,
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            false::BOOLEAN;
        RETURN;
    END IF;

    -- 保有中のNFT数を確認
    SELECT
        COUNT(*) FILTER (WHERE nft_type = 'manual' AND buyback_date IS NULL),
        COUNT(*) FILTER (WHERE nft_type = 'auto' AND buyback_date IS NULL)
    INTO v_available_manual, v_available_auto
    FROM nft_master
    WHERE user_id = p_user_id;

    -- NFT保有数の検証
    IF p_manual_nft_count > v_available_manual THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            FORMAT('手動NFTの保有数が不足しています（保有: %s枚、申請: %s枚）',
                v_available_manual, p_manual_nft_count)::TEXT,
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            false::BOOLEAN;
        RETURN;
    END IF;

    IF p_auto_nft_count > v_available_auto THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            FORMAT('自動NFTの保有数が不足しています（保有: %s枚、申請: %s枚）',
                v_available_auto, p_auto_nft_count)::TEXT,
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            0::DECIMAL(10,2),
            false::BOOLEAN;
        RETURN;
    END IF;

    -- 手動NFTの買い取り金額計算
    FOR v_nft_record IN
        SELECT id
        FROM nft_master
        WHERE user_id = p_user_id
          AND nft_type = 'manual'
          AND buyback_date IS NULL
        ORDER BY nft_sequence ASC
        LIMIT p_manual_nft_count
    LOOP
        v_nft_buyback := calculate_nft_buyback_amount(v_nft_record.id);
        v_manual_buyback := v_manual_buyback + v_nft_buyback;
    END LOOP;

    -- 自動NFTの買い取り金額計算
    FOR v_nft_record IN
        SELECT id
        FROM nft_master
        WHERE user_id = p_user_id
          AND nft_type = 'auto'
          AND buyback_date IS NULL
        ORDER BY nft_sequence ASC
        LIMIT p_auto_nft_count
    LOOP
        v_nft_buyback := calculate_nft_buyback_amount(v_nft_record.id);
        v_auto_buyback := v_auto_buyback + v_nft_buyback;
    END LOOP;

    v_total_buyback := v_manual_buyback + v_auto_buyback;

    -- 買い取り申請レコードを作成（emailカラムは削除）
    INSERT INTO buyback_requests (
        user_id,
        manual_nft_count,
        auto_nft_count,
        total_nft_count,
        manual_buyback_amount,
        auto_buyback_amount,
        total_buyback_amount,
        wallet_address,
        wallet_type,
        status
    )
    VALUES (
        p_user_id,
        p_manual_nft_count,
        p_auto_nft_count,
        p_manual_nft_count + p_auto_nft_count,
        v_manual_buyback,
        v_auto_buyback,
        v_total_buyback,
        p_wallet_address,
        p_wallet_type,
        'pending'
    )
    RETURNING id INTO v_request_id;

    -- 成功レスポンス
    RETURN QUERY SELECT
        v_request_id,
        'SUCCESS'::TEXT,
        FORMAT('買い取り申請を受け付けました。合計金額: $%s', v_total_buyback)::TEXT,
        v_manual_buyback,
        v_auto_buyback,
        v_total_buyback,
        true::BOOLEAN;

EXCEPTION WHEN OTHERS THEN
    RETURN QUERY SELECT
        NULL::UUID,
        'ERROR'::TEXT,
        FORMAT('エラーが発生しました: %s', SQLERRM)::TEXT,
        0::DECIMAL(10,2),
        0::DECIMAL(10,2),
        0::DECIMAL(10,2),
        false::BOOLEAN;
END;
$_$;


ALTER FUNCTION "public"."create_buyback_request"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer, "p_wallet_address" "text", "p_wallet_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_monthly_reward_tasks"("p_year" integer, "p_month" integer) RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_record RECORD;
    v_created_count INTEGER := 0;
BEGIN
    -- 全アクティブユーザーに対してタスクレコードを作成
    FOR v_user_record IN
        SELECT DISTINCT user_id
        FROM users
        WHERE has_approved_nft = true
        AND is_active = true
    LOOP
        INSERT INTO monthly_reward_tasks (
            user_id, year, month, is_completed, questions_answered
        )
        VALUES (
            v_user_record.user_id, p_year, p_month, false, 0
        )
        ON CONFLICT (user_id, year, month) DO NOTHING;
        
        v_created_count := v_created_count + 1;
    END LOOP;
    
    RETURN v_created_count;
END;
$$;


ALTER FUNCTION "public"."create_monthly_reward_tasks"("p_year" integer, "p_month" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_send_to" "text", "p_individual_user_ids" "text"[] DEFAULT NULL::"text"[]) RETURNS TABLE("email_id" "uuid", "total_recipients" integer, "blacklisted_count" integer, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
    v_email_id UUID;
    v_recipient_count INTEGER := 0;
    v_blacklisted_count INTEGER := 0;
    v_user_record RECORD;
BEGIN
    -- システムメール作成
    INSERT INTO system_emails (subject, body, send_to, created_at)
    VALUES (p_subject, p_body, p_send_to, NOW())
    RETURNING id INTO v_email_id;

    -- 送信先ユーザーを決定（email_blacklisted = FALSE のユーザーのみ）
    IF p_send_to = 'all' THEN
        -- 全ユーザー（除外リスト以外）
        FOR v_user_record IN
            SELECT user_id, email
            FROM users
            WHERE (email_blacklisted = FALSE OR email_blacklisted IS NULL)
            ORDER BY created_at DESC
        LOOP
            INSERT INTO email_recipients (email_id, user_id, recipient_email, status)
            VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
            v_recipient_count := v_recipient_count + 1;
        END LOOP;

        -- 除外されたユーザー数をカウント
        SELECT COUNT(*) INTO v_blacklisted_count
        FROM users
        WHERE email_blacklisted = TRUE;

    ELSIF p_send_to = 'approved' THEN
        -- 承認済みユーザー（除外リスト以外）
        FOR v_user_record IN
            SELECT DISTINCT u.user_id, u.email
            FROM users u
            INNER JOIN purchases p ON u.user_id = p.user_id
            WHERE p.admin_approved = TRUE
              AND (u.email_blacklisted = FALSE OR u.email_blacklisted IS NULL)
            ORDER BY u.created_at DESC
        LOOP
            INSERT INTO email_recipients (email_id, user_id, recipient_email, status)
            VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
            v_recipient_count := v_recipient_count + 1;
        END LOOP;

        -- 除外されたユーザー数をカウント
        SELECT COUNT(DISTINCT u.user_id) INTO v_blacklisted_count
        FROM users u
        INNER JOIN purchases p ON u.user_id = p.user_id
        WHERE p.admin_approved = TRUE
          AND u.email_blacklisted = TRUE;

    ELSIF p_send_to = 'unapproved' THEN
        -- 未承認ユーザー（除外リスト以外）
        FOR v_user_record IN
            SELECT u.user_id, u.email
            FROM users u
            WHERE NOT EXISTS (
                SELECT 1 FROM purchases p
                WHERE p.user_id = u.user_id AND p.admin_approved = TRUE
            )
            AND (u.email_blacklisted = FALSE OR u.email_blacklisted IS NULL)
            ORDER BY u.created_at DESC
        LOOP
            INSERT INTO email_recipients (email_id, user_id, recipient_email, status)
            VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
            v_recipient_count := v_recipient_count + 1;
        END LOOP;

        -- 除外されたユーザー数をカウント
        SELECT COUNT(*) INTO v_blacklisted_count
        FROM users u
        WHERE NOT EXISTS (
            SELECT 1 FROM purchases p
            WHERE p.user_id = u.user_id AND p.admin_approved = TRUE
        )
        AND u.email_blacklisted = TRUE;

    ELSIF p_send_to = 'individual' AND p_individual_user_ids IS NOT NULL THEN
        -- 個別指定（除外リスト以外）
        FOR v_user_record IN
            SELECT user_id, email
            FROM users
            WHERE user_id = ANY(p_individual_user_ids)
              AND (email_blacklisted = FALSE OR email_blacklisted IS NULL)
        LOOP
            INSERT INTO email_recipients (email_id, user_id, recipient_email, status)
            VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
            v_recipient_count := v_recipient_count + 1;
        END LOOP;

        -- 除外されたユーザー数をカウント
        SELECT COUNT(*) INTO v_blacklisted_count
        FROM users
        WHERE user_id = ANY(p_individual_user_ids)
          AND email_blacklisted = TRUE;
    END IF;

    -- 結果を返す
    RETURN QUERY SELECT
        v_email_id,
        v_recipient_count,
        v_blacklisted_count,
        FORMAT('メール作成完了: %s名に送信予定（%s名は除外リスト）',
               v_recipient_count, v_blacklisted_count)::TEXT;

EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'メール作成エラー: %', SQLERRM;
END;
$$;


ALTER FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_send_to" "text", "p_individual_user_ids" "text"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_email_type" "text" DEFAULT 'broadcast'::"text", "p_admin_email" "text" DEFAULT NULL::"text", "p_target_group" "text" DEFAULT 'all'::"text", "p_target_user_ids" "text"[] DEFAULT NULL::"text"[]) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_email_id UUID;
    v_recipient_count INTEGER := 0;
    v_user_record RECORD;
    v_html_body TEXT;
BEGIN
    -- 管理者権限チェック
    IF p_admin_email IS NULL OR (
        p_admin_email != 'basarasystems@gmail.com' AND
        p_admin_email != 'support@dshsupport.biz'
    ) THEN
        RAISE EXCEPTION 'Unauthorized: Admin access required';
    END IF;

    -- ⭐ プレーンテキストを自動的にHTMLに変換
    v_html_body := text_to_html(p_body);

    -- システムメールレコードを作成
    INSERT INTO system_emails (
        subject,
        body,
        email_type,
        from_name,
        from_email,
        sent_by,
        target_group,
        created_at
    )
    VALUES (
        p_subject,
        v_html_body,  -- ⭐ 変換後のHTMLを保存
        p_email_type,
        'HASHPILOT',
        'noreply@hashpilot.biz',
        p_admin_email,
        p_target_group,
        NOW()
    )
    RETURNING id INTO v_email_id;

    -- 送信先ユーザーを登録
    IF p_email_type = 'broadcast' THEN
        -- 一斉送信
        IF p_target_group = 'all' THEN
            -- 全ユーザー
            FOR v_user_record IN
                SELECT user_id, email FROM users WHERE email IS NOT NULL
            LOOP
                INSERT INTO email_recipients (email_id, user_id, to_email, status)
                VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
                v_recipient_count := v_recipient_count + 1;
            END LOOP;

        ELSIF p_target_group = 'approved' THEN
            -- 承認済みユーザーのみ
            FOR v_user_record IN
                SELECT user_id, email FROM users WHERE email IS NOT NULL AND has_approved_nft = true
            LOOP
                INSERT INTO email_recipients (email_id, user_id, to_email, status)
                VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
                v_recipient_count := v_recipient_count + 1;
            END LOOP;

        ELSIF p_target_group = 'unapproved' THEN
            -- 未承認ユーザーのみ
            FOR v_user_record IN
                SELECT user_id, email FROM users WHERE email IS NOT NULL AND has_approved_nft = false
            LOOP
                INSERT INTO email_recipients (email_id, user_id, to_email, status)
                VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
                v_recipient_count := v_recipient_count + 1;
            END LOOP;
        END IF;

    ELSIF p_email_type = 'individual' THEN
        -- 個別送信
        IF p_target_user_ids IS NOT NULL AND array_length(p_target_user_ids, 1) > 0 THEN
            FOR v_user_record IN
                SELECT user_id, email FROM users WHERE user_id = ANY(p_target_user_ids) AND email IS NOT NULL
            LOOP
                INSERT INTO email_recipients (email_id, user_id, to_email, status)
                VALUES (v_email_id, v_user_record.user_id, v_user_record.email, 'pending');
                v_recipient_count := v_recipient_count + 1;
            END LOOP;
        END IF;
    END IF;

    -- システムログに記録
    INSERT INTO system_logs (log_type, operation, message, details)
    VALUES (
        'SUCCESS',
        'create_system_email',
        format('システムメールを作成しました: %s (%s件)', p_subject, v_recipient_count),
        jsonb_build_object(
            'email_id', v_email_id,
            'email_type', p_email_type,
            'target_group', p_target_group,
            'recipient_count', v_recipient_count,
            'admin_email', p_admin_email
        )
    );

    RETURN json_build_object(
        'success', true,
        'email_id', v_email_id,
        'recipient_count', v_recipient_count
    );

EXCEPTION WHEN OTHERS THEN
    RAISE EXCEPTION 'Error creating system email: %', SQLERRM;
END;
$$;


ALTER FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_email_type" "text", "p_admin_email" "text", "p_target_group" "text", "p_target_user_ids" "text"[]) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_withdrawal_request"("p_user_id" "text", "p_amount" numeric, "p_wallet_address" "text", "p_wallet_type" "text" DEFAULT 'USDT-TRC20'::"text") RETURNS TABLE("request_id" "uuid", "status" "text", "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
    v_available_usdt NUMERIC;
    v_request_id UUID;
    v_user_exists BOOLEAN;
    v_is_pegasus_exchange BOOLEAN;
BEGIN
    -- ユーザー存在確認とペガサス情報取得
    SELECT
        EXISTS(SELECT 1 FROM users WHERE user_id = p_user_id),
        COALESCE(is_pegasus_exchange, FALSE)
    INTO
        v_user_exists,
        v_is_pegasus_exchange
    FROM users
    WHERE user_id = p_user_id;

    IF NOT v_user_exists THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            'ユーザーが存在しません'::TEXT;
        RETURN;
    END IF;

    -- ⭐ ペガサス交換ユーザーの出金制限チェック（シンプル版）
    IF v_is_pegasus_exchange = TRUE THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '⚠️ ペガサス交換ユーザーのため、現在出金できません。通常運用に戻すには管理者に連絡してください。'::TEXT;
        RETURN;
    END IF;

    -- 入力値検証
    IF p_amount <= 0 THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '出金額は0より大きい必要があります'::TEXT;
        RETURN;
    END IF;

    IF p_amount < 100 THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '最小出金額は$100です'::TEXT;
        RETURN;
    END IF;

    IF LENGTH(p_wallet_address) < 10 THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '有効なウォレットアドレスを入力してください'::TEXT;
        RETURN;
    END IF;

    -- 利用可能残高確認
    SELECT COALESCE(available_usdt, 0)
    FROM affiliate_cycle
    WHERE user_id = p_user_id
    INTO v_available_usdt;

    IF v_available_usdt IS NULL THEN
        v_available_usdt := 0;
    END IF;

    IF v_available_usdt < p_amount THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            FORMAT('残高不足です。利用可能額: $%s', v_available_usdt)::TEXT;
        RETURN;
    END IF;

    -- 保留中の出金申請確認
    IF EXISTS(SELECT 1 FROM withdrawal_requests
              WHERE user_id = p_user_id AND status = 'pending') THEN
        RETURN QUERY SELECT
            NULL::UUID,
            'ERROR'::TEXT,
            '保留中の出金申請があります。完了後に再申請してください'::TEXT;
        RETURN;
    END IF;

    -- 出金申請作成
    INSERT INTO withdrawal_requests (
        user_id, amount, wallet_address, wallet_type,
        available_usdt_before, available_usdt_after,
        status, created_at, updated_at
    )
    VALUES (
        p_user_id, p_amount, p_wallet_address, p_wallet_type,
        v_available_usdt, v_available_usdt - p_amount,
        'pending', NOW(), NOW()
    )
    RETURNING id INTO v_request_id;

    -- affiliate_cycleの利用可能残高を減額（仮減額）
    UPDATE affiliate_cycle
    SET
        available_usdt = available_usdt - p_amount,
        last_updated = NOW()
    WHERE user_id = p_user_id;

    -- ログ記録
    PERFORM log_system_event(
        'INFO',
        'WITHDRAWAL_REQUEST',
        p_user_id,
        FORMAT('出金申請作成: $%s → %s', p_amount, p_wallet_address),
        jsonb_build_object(
            'request_id', v_request_id,
            'amount', p_amount,
            'wallet_address', p_wallet_address,
            'wallet_type', p_wallet_type,
            'available_before', v_available_usdt,
            'available_after', v_available_usdt - p_amount,
            'is_pegasus_exchange', v_is_pegasus_exchange
        )
    );

    RETURN QUERY SELECT
        v_request_id,
        'SUCCESS'::TEXT,
        FORMAT('出金申請を受付ました。申請ID: %s', v_request_id)::TEXT;

EXCEPTION WHEN OTHERS THEN
    RETURN QUERY SELECT
        NULL::UUID,
        'ERROR'::TEXT,
        FORMAT('エラーが発生しました: %s', SQLERRM)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."create_withdrawal_request"("p_user_id" "text", "p_amount" numeric, "p_wallet_address" "text", "p_wallet_type" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_withdrawal_request"("p_user_id" "text", "p_amount" numeric, "p_wallet_address" "text", "p_wallet_type" "text") IS '出金申請作成（ペガサス交換ユーザーは無条件で出金不可）';



CREATE OR REPLACE FUNCTION "public"."delete_purchase_record"("purchase_id" "uuid", "admin_email" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (
        SELECT 1 FROM admins 
        WHERE email = admin_email AND is_active = true
    ) THEN
        RAISE EXCEPTION '管理者権限がありません';
    END IF;

    -- 購入レコードが存在するかチェック
    IF NOT EXISTS (
        SELECT 1 FROM purchases WHERE id = purchase_id
    ) THEN
        RAISE EXCEPTION '購入レコードが見つかりません';
    END IF;

    -- 購入レコードを削除
    DELETE FROM purchases WHERE id = purchase_id;

    RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."delete_purchase_record"("purchase_id" "uuid", "admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_completely"("target_user_id" character varying, "admin_user_id" character varying) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    user_info RECORD;
    deletion_result JSON;
    auth_user_uuid UUID;
BEGIN
    -- 管理者権限チェック
    IF NOT is_admin(admin_user_id) THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Unauthorized: Admin access required'
        );
    END IF;

    -- ユーザー情報を取得
    SELECT * INTO user_info FROM users WHERE user_id = target_user_id;
    
    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'User not found'
        );
    END IF;

    -- 削除ログを記録
    INSERT INTO user_deletion_logs (
        deleted_user_id,
        deleted_email,
        admin_user_id,
        deletion_reason,
        user_data_backup
    ) VALUES (
        target_user_id,
        user_info.email,
        admin_user_id,
        'Admin deletion',
        row_to_json(user_info)
    );

    -- 関連データを削除
    DELETE FROM purchases WHERE user_id = target_user_id;
    
    -- 紹介関係を削除
    UPDATE users SET referrer_user_id = NULL WHERE referrer_user_id = target_user_id;
    
    -- ユーザーレコードを削除
    DELETE FROM users WHERE user_id = target_user_id;

    -- Supabase Authからも削除を試行
    BEGIN
        SELECT id INTO auth_user_uuid FROM auth.users WHERE raw_user_meta_data->>'user_id' = target_user_id;
        IF FOUND THEN
            DELETE FROM auth.users WHERE id = auth_user_uuid;
        END IF;
    EXCEPTION WHEN OTHERS THEN
        -- Auth削除エラーは無視（ログに記録済み）
        NULL;
    END;

    RETURN json_build_object(
        'success', true,
        'message', 'User deleted successfully',
        'deleted_user_id', target_user_id,
        'deleted_email', user_info.email
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'success', false,
        'error', SQLERRM
    );
END;
$$;


ALTER FUNCTION "public"."delete_user_completely"("target_user_id" character varying, "admin_user_id" character varying) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_completely"("target_user_id" "text", "admin_email" "text", "deletion_reason" "text" DEFAULT 'Admin deletion'::"text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    user_record RECORD;
    auth_user_id UUID;
    deleted_data JSONB;
BEGIN
    -- 管理者権限チェック
    IF NOT is_admin(admin_email) THEN
        RAISE EXCEPTION 'Admin privileges required';
    END IF;

    -- ユーザー情報取得
    SELECT * INTO user_record FROM users WHERE user_id = target_user_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'User not found: %', target_user_id;
    END IF;

    -- auth.usersからuser_idを取得
    SELECT id INTO auth_user_id 
    FROM auth.users 
    WHERE email = user_record.email;

    -- 削除データの記録準備
    SELECT jsonb_build_object(
        'user_data', row_to_json(user_record),
        'purchases', (
            SELECT jsonb_agg(row_to_json(p)) 
            FROM purchases p 
            WHERE p.user_id = target_user_id
        ),
        'referrals', (
            SELECT jsonb_agg(row_to_json(r)) 
            FROM users r 
            WHERE r.referrer_user_id = target_user_id
        )
    ) INTO deleted_data;

    -- 関連データの削除（順序重要）
    
    -- 1. 紹介関係の更新（このユーザーを紹介者とする他のユーザー）
    UPDATE users 
    SET referrer_user_id = NULL 
    WHERE referrer_user_id = target_user_id;

    -- 2. 購入記録の削除
    DELETE FROM purchases WHERE user_id = target_user_id;

    -- 3. ユーザーレコードの削除
    DELETE FROM users WHERE user_id = target_user_id;

    -- 4. Supabase Authからの削除（存在する場合）
    IF auth_user_id IS NOT NULL THEN
        DELETE FROM auth.users WHERE id = auth_user_id;
    END IF;

    -- 5. 削除ログの記録
    INSERT INTO user_deletion_logs (
        deleted_user_id,
        deleted_email,
        admin_email,
        deletion_reason,
        deleted_data
    ) VALUES (
        target_user_id,
        user_record.email,
        admin_email,
        deletion_reason,
        deleted_data
    );

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to delete user: %', SQLERRM;
END;
$$;


ALTER FUNCTION "public"."delete_user_completely"("target_user_id" "text", "admin_email" "text", "deletion_reason" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_safely"("p_user_id" "text", "p_admin_email" "text") RETURNS TABLE("status" "text", "message" "text", "details" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_deleted_tables JSONB := '[]'::JSONB;
    v_row_count INTEGER;
    v_user_email TEXT;
BEGIN
    -- ユーザーのメールアドレスを取得
    SELECT email INTO v_user_email
    FROM users
    WHERE user_id = p_user_id;

    IF NOT FOUND THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            FORMAT('ユーザーID %s が見つかりません', p_user_id)::TEXT,
            '{}'::JSONB;
        RETURN;
    END IF;

    -- 削除処理開始
    RAISE NOTICE '削除開始: ユーザーID=%, メール=%', p_user_id, v_user_email;

    -- 1. nft_daily_profit から削除（user_daily_profitはVIEWなのでスキップ）
    DELETE FROM nft_daily_profit WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'nft_daily_profit', 'rows', v_row_count);
    END IF;

    -- 2. nft_holdings から削除
    DELETE FROM nft_holdings WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'nft_holdings', 'rows', v_row_count);
    END IF;

    -- 3. nft_master から削除
    DELETE FROM nft_master WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'nft_master', 'rows', v_row_count);
    END IF;

    -- 4. purchases から削除
    DELETE FROM purchases WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'purchases', 'rows', v_row_count);
    END IF;

    -- 5. buyback_requests から削除
    DELETE FROM buyback_requests WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'buyback_requests', 'rows', v_row_count);
    END IF;

    -- 6. monthly_withdrawals から削除
    DELETE FROM monthly_withdrawals WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'monthly_withdrawals', 'rows', v_row_count);
    END IF;

    -- 7. affiliate_cycle から削除
    DELETE FROM affiliate_cycle WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'affiliate_cycle', 'rows', v_row_count);
    END IF;

    -- 8. email_recipients から削除
    DELETE FROM email_recipients WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'email_recipients', 'rows', v_row_count);
    END IF;

    -- 9. monthly_reward_tasks から削除
    DELETE FROM monthly_reward_tasks WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'monthly_reward_tasks', 'rows', v_row_count);
    END IF;

    -- 10. このユーザーを紹介者としているユーザーの参照をNULLに
    UPDATE users SET referrer_user_id = NULL WHERE referrer_user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'users(referrer更新)', 'rows', v_row_count);
    END IF;

    -- 11. 最後に users テーブルから削除
    DELETE FROM users WHERE user_id = p_user_id;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count > 0 THEN
        v_deleted_tables := v_deleted_tables || jsonb_build_object('table', 'users', 'rows', v_row_count);
    END IF;

    -- 成功レスポンス
    RETURN QUERY SELECT
        'SUCCESS'::TEXT,
        FORMAT('ユーザー %s (ID: %s) を削除しました', v_user_email, p_user_id)::TEXT,
        jsonb_build_object(
            'deleted_from_tables', v_deleted_tables,
            'admin_email', p_admin_email,
            'deleted_user_email', v_user_email
        );

EXCEPTION WHEN OTHERS THEN
    RETURN QUERY SELECT
        'ERROR'::TEXT,
        FORMAT('削除中にエラーが発生しました: %s', SQLERRM)::TEXT,
        jsonb_build_object('error_detail', SQLERRM);
END;
$$;


ALTER FUNCTION "public"."delete_user_safely"("p_user_id" "text", "p_admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fix_referral_data"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    user_record RECORD;
    referrer_code text;
    coinw_uid_value text;
BEGIN
    -- auth.usersからメタデータを取得してusersテーブルを更新
    FOR user_record IN 
        SELECT 
            au.id,
            au.email,
            au.raw_user_meta_data,
            u.user_id
        FROM auth.users au
        LEFT JOIN users u ON au.id = u.id
        WHERE au.raw_user_meta_data IS NOT NULL
    LOOP
        -- referrer_user_idを取得（修正：user_recordを使用）
        referrer_code := user_record.raw_user_meta_data->>'referrer_user_id';
        coinw_uid_value := user_record.raw_user_meta_data->>'coinw_uid';
        
        -- usersテーブルを更新
        UPDATE users 
        SET 
            referrer_user_id = CASE 
                WHEN referrer_code IS NOT NULL AND referrer_code != '' 
                THEN referrer_code 
                ELSE referrer_user_id 
            END,
            coinw_uid = CASE 
                WHEN coinw_uid_value IS NOT NULL AND coinw_uid_value != '' 
                THEN coinw_uid_value 
                ELSE coinw_uid 
            END,
            updated_at = NOW()
        WHERE id = user_record.id;
        
        RAISE NOTICE 'Updated user %: referrer=%, coinw_uid=%', 
            user_record.email, referrer_code, coinw_uid_value;
    END LOOP;
END;
$$;


ALTER FUNCTION "public"."fix_referral_data"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."fix_user_daily_profit_rls"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  result_message TEXT := '';
BEGIN
  -- Enable RLS on user_daily_profit table
  BEGIN
    ALTER TABLE user_daily_profit ENABLE ROW LEVEL SECURITY;
    result_message := result_message || 'RLS enabled on user_daily_profit table. ';
  EXCEPTION WHEN OTHERS THEN
    result_message := result_message || 'RLS already enabled. ';
  END;

  -- Drop existing policies
  BEGIN
    DROP POLICY IF EXISTS "Users can view own profit data" ON user_daily_profit;
    DROP POLICY IF EXISTS "Allow users to view their own profit data" ON user_daily_profit;
    DROP POLICY IF EXISTS "Enable read access for authenticated users" ON user_daily_profit;
    DROP POLICY IF EXISTS "Admins can view all profit data" ON user_daily_profit;
    result_message := result_message || 'Existing policies dropped. ';
  EXCEPTION WHEN OTHERS THEN
    result_message := result_message || 'Policy drop warning: ' || SQLERRM || '. ';
  END;

  -- Create new policy for users to view their own data
  BEGIN
    CREATE POLICY "Users can view own profit data" ON user_daily_profit
    FOR SELECT
    TO authenticated
    USING (
      user_id IN (
        SELECT user_id 
        FROM users 
        WHERE id = auth.uid()
      )
    );
    result_message := result_message || 'User view policy created. ';
  EXCEPTION WHEN OTHERS THEN
    result_message := result_message || 'User policy error: ' || SQLERRM || '. ';
  END;

  -- Create admin policy
  BEGIN
    CREATE POLICY "Admins can view all profit data" ON user_daily_profit
    FOR ALL
    TO authenticated
    USING (
      EXISTS (
        SELECT 1 FROM admins 
        WHERE email = auth.jwt()->>'email' 
        AND is_active = true
      )
    );
    result_message := result_message || 'Admin policy created. ';
  EXCEPTION WHEN OTHERS THEN
    result_message := result_message || 'Admin policy error: ' || SQLERRM || '. ';
  END;

  RETURN result_message || 'RLS fix completed successfully.';
EXCEPTION WHEN OTHERS THEN
  RETURN 'Error: ' || SQLERRM;
END;
$$;


ALTER FUNCTION "public"."fix_user_daily_profit_rls"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_user_id"() RETURNS character varying
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  new_id VARCHAR(6);
  done BOOLEAN := false;
BEGIN
  WHILE NOT done LOOP
    new_id := UPPER(
      SUBSTRING(
        REPLACE(
          REPLACE(
            encode(gen_random_bytes(4), 'base64'),
            '+', ''
          ),
          '/', ''
        ),
        1, 6
      )
    );
    
    -- 数字と英字のみに制限
    new_id := REGEXP_REPLACE(new_id, '[^A-Z0-9]', '', 'g');
    
    IF LENGTH(new_id) >= 6 THEN
      new_id := SUBSTRING(new_id, 1, 6);
      
      -- 重複チェック
      IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = new_id) THEN
        done := true;
      END IF;
    END IF;
  END LOOP;
  
  RETURN new_id;
END;
$$;


ALTER FUNCTION "public"."generate_user_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_admin_list"() RETURNS TABLE("email" "text", "is_active" boolean, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT a.email, a.is_active, a.created_at
    FROM admins a
    ORDER BY a.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_admin_list"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_admin_purchases"() RETURNS TABLE("id" "uuid", "user_id" "text", "email" "text", "coinw_uid" "text", "amount" numeric, "transaction_id" "text", "status" "text", "created_at" timestamp with time zone, "referrer_user_id" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        u.user_id::text,
        u.email,
        u.coinw_uid,
        p.amount,
        p.transaction_id,
        p.status,
        p.created_at,
        u.referrer_user_id
    FROM purchases p
    JOIN users u ON p.user_id = u.id
    ORDER BY p.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_admin_purchases"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_admin_users"() RETURNS TABLE("user_id" "text", "email" "text", "coinw_uid" "text", "referrer_user_id" "text", "total_purchases" numeric, "is_active" boolean, "has_approved_nft" boolean, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (
        SELECT 1 FROM admins a 
        JOIN users u ON u.email = a.email
        WHERE u.id = auth.uid() AND a.is_active = TRUE
    ) THEN
        RAISE EXCEPTION '管理者権限が必要です';
    END IF;
    
    -- ユーザーデータを返す
    RETURN QUERY
    SELECT 
        u.user_id::TEXT,  -- TEXT型にキャスト
        u.email,
        u.coinw_uid,
        u.referrer_user_id::TEXT,  -- TEXT型にキャスト
        COALESCE(u.total_purchases, 0) as total_purchases,
        u.is_active,
        u.has_approved_nft,
        u.created_at
    FROM users u
    ORDER BY u.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_admin_users"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_all_buyback_requests"("p_status" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "user_id" "text", "email" "text", "full_name" "text", "request_date" timestamp with time zone, "manual_nft_count" integer, "auto_nft_count" integer, "total_nft_count" integer, "manual_buyback_amount" numeric, "auto_buyback_amount" numeric, "total_buyback_amount" numeric, "wallet_address" "text", "wallet_type" "text", "status" "text", "processed_by" "text", "processed_at" timestamp with time zone, "transaction_hash" "text", "admin_notes" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
    IF p_status IS NULL THEN
        RETURN QUERY
        SELECT
            br.id,
            br.user_id,
            u.email::TEXT,
            u.full_name::TEXT,
            br.created_at as request_date,
            br.manual_nft_count,
            br.auto_nft_count,
            br.total_nft_count,
            br.manual_buyback_amount,
            br.auto_buyback_amount,
            br.total_buyback_amount,
            br.wallet_address,
            br.wallet_type,
            br.status,
            br.processed_by,
            br.processed_at,
            br.transaction_hash,
            br.admin_notes,
            br.created_at
        FROM buyback_requests br
        LEFT JOIN users u ON br.user_id = u.user_id
        ORDER BY br.created_at DESC;
    ELSE
        RETURN QUERY
        SELECT
            br.id,
            br.user_id,
            u.email::TEXT,
            u.full_name::TEXT,
            br.created_at as request_date,
            br.manual_nft_count,
            br.auto_nft_count,
            br.total_nft_count,
            br.manual_buyback_amount,
            br.auto_buyback_amount,
            br.total_buyback_amount,
            br.wallet_address,
            br.wallet_type,
            br.status,
            br.processed_by,
            br.processed_at,
            br.transaction_hash,
            br.admin_notes,
            br.created_at
        FROM buyback_requests br
        LEFT JOIN users u ON br.user_id = u.user_id
        WHERE br.status = p_status
        ORDER BY br.created_at DESC;
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_all_buyback_requests"("p_status" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_auto_purchase_history"("p_user_id" "text", "p_limit" integer DEFAULT 10) RETURNS TABLE("purchase_id" "uuid", "purchase_date" timestamp with time zone, "nft_quantity" integer, "amount_usd" numeric, "cycle_number" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        p.id,
        p.created_at,
        p.nft_quantity,
        p.amount_usd,
        COALESCE(p.cycle_number_at_purchase, 1) as cycle_number  -- 購入時のサイクル番号を使用
    FROM purchases p
    WHERE p.user_id = p_user_id
      AND p.is_auto_purchase = true
      AND p.admin_approved = true
    ORDER BY p.created_at DESC
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_auto_purchase_history"("p_user_id" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_buyback_requests"("p_user_id" "text") RETURNS TABLE("id" "uuid", "user_id" "text", "request_date" timestamp with time zone, "manual_nft_count" integer, "auto_nft_count" integer, "total_nft_count" integer, "manual_buyback_amount" numeric, "auto_buyback_amount" numeric, "total_buyback_amount" numeric, "wallet_address" "text", "wallet_type" "text", "status" "text", "processed_by" "text", "processed_at" timestamp with time zone, "transaction_hash" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        br.id,
        br.user_id,
        br.created_at as request_date,  -- created_atをrequest_dateとして返す
        br.manual_nft_count,
        br.auto_nft_count,
        br.total_nft_count,
        br.manual_buyback_amount,
        br.auto_buyback_amount,
        br.total_buyback_amount,
        br.wallet_address,
        br.wallet_type,
        br.status,
        br.processed_by,
        br.processed_at,
        br.transaction_hash,
        br.created_at
    FROM buyback_requests br
    WHERE br.user_id = p_user_id
    ORDER BY br.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_buyback_requests"("p_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_company_bonus_report"("p_start_date" "date" DEFAULT (CURRENT_DATE - '30 days'::interval), "p_end_date" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("report_date" "date", "total_bonus" numeric, "bonus_count" integer, "dormant_users_count" integer, "level1_bonus" numeric, "level2_bonus" numeric, "level3_bonus" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        cb.date as report_date,
        SUM(cb.original_amount) as total_bonus,
        COUNT(*)::INTEGER as bonus_count,
        COUNT(DISTINCT cb.dormant_user_id)::INTEGER as dormant_users_count,
        SUM(CASE WHEN cb.referral_level = 1 THEN cb.original_amount ELSE 0 END) as level1_bonus,
        SUM(CASE WHEN cb.referral_level = 2 THEN cb.original_amount ELSE 0 END) as level2_bonus,
        SUM(CASE WHEN cb.referral_level = 3 THEN cb.original_amount ELSE 0 END) as level3_bonus
    FROM company_bonus_from_dormant cb
    WHERE cb.date BETWEEN p_start_date AND p_end_date
    GROUP BY cb.date
    ORDER BY cb.date DESC;
END;
$$;


ALTER FUNCTION "public"."get_company_bonus_report"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_deletion_logs"("limit_count" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "deleted_user_id" "text", "deleted_email" "text", "admin_email" "text", "deletion_reason" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        dl.id,
        dl.deleted_user_id,
        dl.deleted_email,
        dl.admin_email,
        dl.deletion_reason,
        dl.created_at
    FROM user_deletion_logs dl
    ORDER BY dl.created_at DESC
    LIMIT limit_count;
END;
$$;


ALTER FUNCTION "public"."get_deletion_logs"("limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_email_delivery_details"("p_email_id" "uuid", "p_admin_email" "text") RETURNS TABLE("recipient_id" "uuid", "user_id" "text", "user_email" "text", "full_name" "text", "status" "text", "sent_at" timestamp with time zone, "read_at" timestamp with time zone, "error_message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- 管理者権限チェック
    IF NOT is_system_admin(p_admin_email) THEN
        RAISE EXCEPTION '管理者権限がありません';
    END IF;

    RETURN QUERY
    SELECT
        er.id as recipient_id,
        er.user_id,
        er.to_email as user_email,
        u.full_name,
        er.status,
        er.sent_at,
        er.read_at,
        er.error_message
    FROM email_recipients er
    INNER JOIN users u ON er.user_id = u.user_id
    WHERE er.email_id = p_email_id
    ORDER BY er.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_email_delivery_details"("p_email_id" "uuid", "p_admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_email_history"("p_admin_email" "text", "p_limit" integer DEFAULT 50) RETURNS TABLE("email_id" "uuid", "subject" "text", "email_type" "text", "target_group" "text", "created_at" timestamp with time zone, "total_recipients" integer, "sent_count" integer, "failed_count" integer, "read_count" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- 管理者権限チェック
    IF NOT is_system_admin(p_admin_email) THEN
        RAISE EXCEPTION '管理者権限がありません';
    END IF;

    RETURN QUERY
    SELECT
        se.id as email_id,
        se.subject,
        se.email_type,
        se.target_group,
        se.created_at,
        COUNT(er.id)::INTEGER as total_recipients,
        COUNT(CASE WHEN er.status = 'sent' THEN 1 END)::INTEGER as sent_count,
        COUNT(CASE WHEN er.status = 'failed' THEN 1 END)::INTEGER as failed_count,
        COUNT(CASE WHEN er.status = 'read' THEN 1 END)::INTEGER as read_count
    FROM system_emails se
    LEFT JOIN email_recipients er ON se.id = er.email_id
    WHERE se.sent_by = p_admin_email
    GROUP BY se.id
    ORDER BY se.created_at DESC
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_email_history"("p_admin_email" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_japan_date"() RETURNS "date"
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT (NOW() AT TIME ZONE 'Asia/Tokyo')::DATE;
$$;


ALTER FUNCTION "public"."get_japan_date"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_japan_now"() RETURNS timestamp without time zone
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT NOW() AT TIME ZONE 'Asia/Tokyo';
$$;


ALTER FUNCTION "public"."get_japan_now"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_japan_year_month"() RETURNS TABLE("year" integer, "month" integer)
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT
        EXTRACT(YEAR FROM get_japan_date())::INTEGER,
        EXTRACT(MONTH FROM get_japan_date())::INTEGER;
$$;


ALTER FUNCTION "public"."get_japan_year_month"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_max_referral_depth"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    max_depth INTEGER := 0;
    current_depth INTEGER;
BEGIN
    -- すべてのルートユーザー（紹介者なし）から開始
    WITH RECURSIVE depth_check AS (
        -- ルートユーザー
        SELECT 
            user_id,
            0 as depth
        FROM users 
        WHERE referrer_user_id IS NULL
        
        UNION ALL
        
        -- 子ノード
        SELECT 
            u.user_id,
            dc.depth + 1
        FROM users u
        INNER JOIN depth_check dc ON u.referrer_user_id = dc.user_id
        WHERE dc.depth < 50  -- 安全のため50階層まで
    )
    SELECT MAX(depth) INTO max_depth FROM depth_check;
    
    RETURN COALESCE(max_depth, 0);
END;
$$;


ALTER FUNCTION "public"."get_max_referral_depth"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_month_end"("p_date" "date") RETURNS "date"
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT (DATE_TRUNC('month', p_date) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
$$;


ALTER FUNCTION "public"."get_month_end"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_month_start"("p_date" "date") RETURNS "date"
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT DATE_TRUNC('month', p_date)::DATE;
$$;


ALTER FUNCTION "public"."get_month_start"("p_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_nft_distribution_summary"() RETURNS TABLE("total_users" integer, "nft_distributed_users" integer, "nft_pending_users" integer, "distribution_rate" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_users,
        COUNT(CASE WHEN nft_distributed = TRUE THEN 1 END)::INTEGER as nft_distributed_users,
        COUNT(CASE WHEN nft_distributed = FALSE OR nft_distributed IS NULL THEN 1 END)::INTEGER as nft_pending_users,
        ROUND(
            (COUNT(CASE WHEN nft_distributed = TRUE THEN 1 END)::NUMERIC / NULLIF(COUNT(*)::NUMERIC, 0)) * 100,
            2
        ) as distribution_rate
    FROM users
    WHERE email NOT IN ('basarasystems@gmail.com', 'support@dshsupport.biz'); -- 管理者アカウントを除外
END;
$$;


ALTER FUNCTION "public"."get_nft_distribution_summary"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_nft_status"() RETURNS TABLE("user_id" "text", "email" "text", "full_name" "text", "nft_address" "text", "nft_sent" boolean, "nft_sent_at" timestamp with time zone, "nft_sent_by" "text", "total_purchases" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    u.user_id,
    u.email,
    u.full_name,
    u.nft_address,
    u.nft_sent,
    u.nft_sent_at,
    u.nft_sent_by,
    u.total_purchases
  FROM users u
  WHERE u.total_purchases > 0
  ORDER BY u.nft_sent ASC, u.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_nft_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_payment_addresses"() RETURNS TABLE("bep20_address" "text", "trc20_address" "text", "nft_price" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.usdt_address_bep20,
        s.usdt_address_trc20,
        s.nft_price
    FROM system_settings s
    WHERE s.id = 1;
END;
$$;


ALTER FUNCTION "public"."get_payment_addresses"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_random_questions"("p_count" integer DEFAULT 5) RETURNS TABLE("id" "uuid", "question" "text", "option_a" "text", "option_b" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        rq.id,
        rq.question,
        rq.option_a,
        rq.option_b
    FROM reward_questions rq
    WHERE rq.is_active = true
    ORDER BY RANDOM()
    LIMIT p_count;
END;
$$;


ALTER FUNCTION "public"."get_random_questions"("p_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_referral_profits"("p_user_id" "text", "p_date" "date", "p_month_start" "date", "p_month_end" "date") RETURNS TABLE("level" integer, "yesterday_profit" numeric, "monthly_profit" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    -- Level1: 全ての紹介報酬（現在のDB構造では分離されていない）
    SELECT 
        1 as level,
        COALESCE(SUM(CASE WHEN udp.date = p_date THEN udp.referral_profit ELSE 0 END), 0) as yesterday_profit,
        COALESCE(SUM(CASE WHEN udp.date >= p_month_start AND udp.date <= p_month_end THEN udp.referral_profit ELSE 0 END), 0) as monthly_profit
    FROM user_daily_profit udp
    WHERE udp.user_id = p_user_id
    AND udp.date >= p_month_start
    AND udp.date <= p_date
    
    UNION ALL
    
    -- Level2: 現在のDB構造では0（将来的に分離される可能性がある）
    SELECT 
        2 as level,
        0::NUMERIC as yesterday_profit,
        0::NUMERIC as monthly_profit
    
    UNION ALL
    
    -- Level3: 現在のDB構造では0
    SELECT 
        3 as level,
        0::NUMERIC as yesterday_profit,
        0::NUMERIC as monthly_profit;
END;
$$;


ALTER FUNCTION "public"."get_referral_profits"("p_user_id" "text", "p_date" "date", "p_month_start" "date", "p_month_end" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_referral_stats"("target_user_id" "text") RETURNS TABLE("total_direct_referrals" integer, "total_indirect_referrals" integer, "total_referral_purchases" numeric, "max_tree_depth" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    WITH tree_data AS (
        SELECT * FROM get_referral_tree(target_user_id)
    )
    SELECT 
        COUNT(CASE WHEN level_num = 1 THEN 1 END)::INTEGER as total_direct_referrals,
        COUNT(CASE WHEN level_num > 1 THEN 1 END)::INTEGER as total_indirect_referrals,
        SUM(personal_purchases)::NUMERIC as total_referral_purchases,
        COALESCE(MAX(level_num), 0)::INTEGER as max_tree_depth
    FROM tree_data;
END;
$$;


ALTER FUNCTION "public"."get_referral_stats"("target_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_referral_tree"("root_user_id" "text") RETURNS TABLE("user_id" "text", "email" "text", "full_name" "text", "coinw_uid" "text", "level_num" integer, "total_investment" numeric, "nft_count" integer, "path" "text", "parent_user_id" "text", "personal_purchases" numeric, "subtree_total" numeric, "referrer_id" "text", "direct_referrals_count" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE referral_tree AS (
        -- Base case: direct referrals (level 1)
        SELECT 
            u.user_id::text,
            u.email::text,
            u.full_name::text,
            u.coinw_uid::text,
            1 as level_num,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100) * 1000 as total_investment,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100)::integer as nft_count,
            u.user_id::text as path,
            u.referrer_user_id::text as parent_user_id,
            COALESCE(u.total_purchases, 0) as personal_purchases
        FROM users u
        WHERE u.referrer_user_id = root_user_id
        
        UNION ALL
        
        -- Recursive case: indirect referrals (無制限、最大100レベル)
        SELECT 
            u.user_id::text,
            u.email::text,
            u.full_name::text,
            u.coinw_uid::text,
            rt.level_num + 1,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100) * 1000 as total_investment,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100)::integer as nft_count,
            (rt.path || '->' || u.user_id)::text as path,
            u.referrer_user_id::text as parent_user_id,
            COALESCE(u.total_purchases, 0) as personal_purchases
        FROM users u
        INNER JOIN referral_tree rt ON u.referrer_user_id = rt.user_id
        WHERE rt.level_num < 100
    ),
    -- 各ユーザーの下位ツリーの合計を計算
    subtree_totals AS (
        SELECT 
            rt1.user_id,
            COALESCE(SUM(rt2.personal_purchases), 0) as subtree_sum
        FROM referral_tree rt1
        LEFT JOIN referral_tree rt2 ON rt2.path LIKE rt1.user_id || '%' AND rt2.user_id != rt1.user_id
        GROUP BY rt1.user_id
    ),
    -- 直接紹介者数を計算
    direct_refs AS (
        SELECT 
            referrer_user_id,
            COUNT(*) as count
        FROM users
        WHERE referrer_user_id IS NOT NULL
        GROUP BY referrer_user_id
    )
    SELECT 
        rt.user_id,
        rt.email,
        rt.full_name,
        rt.coinw_uid,
        rt.level_num,
        rt.total_investment,
        rt.nft_count,
        rt.path,
        rt.parent_user_id,
        rt.personal_purchases,
        COALESCE(st.subtree_sum, 0) as subtree_total,
        rt.parent_user_id as referrer_id,
        COALESCE(dr.count, 0)::integer as direct_referrals_count
    FROM referral_tree rt
    LEFT JOIN subtree_totals st ON rt.user_id = st.user_id
    LEFT JOIN direct_refs dr ON rt.user_id = dr.referrer_user_id
    ORDER BY rt.level_num, rt.user_id;
END;
$$;


ALTER FUNCTION "public"."get_referral_tree"("root_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_referral_tree_revenue"("p_user_id" "text") RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
DECLARE
    v_total_revenue NUMERIC := 0;
BEGIN
    -- 再帰クエリで紹介ツリー全体のNFT数を計算し、$1,000を掛ける
    WITH RECURSIVE referral_tree AS (
        -- ルートユーザー
        SELECT user_id, total_purchases
        FROM users
        WHERE user_id = p_user_id

        UNION ALL

        -- 子孫ユーザー（最大500レベル）
        SELECT u.user_id, u.total_purchases
        FROM users u
        INNER JOIN referral_tree rt ON u.referrer_user_id = rt.user_id
    )
    SELECT COALESCE(SUM(FLOOR(total_purchases / 1100) * 1000), 0)
    INTO v_total_revenue
    FROM referral_tree;

    RETURN v_total_revenue;
END;
$_$;


ALTER FUNCTION "public"."get_referral_tree_revenue"("p_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_referral_tree_user"("root_user_id" "text") RETURNS TABLE("user_id" "text", "email" "text", "full_name" "text", "coinw_uid" "text", "level_num" integer, "total_investment" numeric, "nft_count" integer, "path" "text", "parent_user_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE referral_tree AS (
        -- Base case: direct referrals (level 1)
        SELECT 
            u.user_id::text,
            u.email::text,
            u.full_name::text,
            u.coinw_uid::text,
            1 as level_num,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100) * 1000 as total_investment,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100)::integer as nft_count,  -- 明示的にintegerにキャスト
            u.user_id::text as path,
            u.referrer_user_id::text as parent_user_id
        FROM users u
        WHERE u.referrer_user_id = root_user_id
        
        UNION ALL
        
        -- Recursive case: indirect referrals (levels 2, 3)
        SELECT 
            u.user_id::text,
            u.email::text,
            u.full_name::text,
            u.coinw_uid::text,
            rt.level_num + 1,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100) * 1000 as total_investment,
            FLOOR(COALESCE(u.total_purchases, 0) / 1100)::integer as nft_count,  -- 明示的にintegerにキャスト
            (rt.path || '->' || u.user_id)::text as path,
            u.referrer_user_id::text as parent_user_id
        FROM users u
        INNER JOIN referral_tree rt ON u.referrer_user_id = rt.user_id
        WHERE rt.level_num < 3  -- ユーザー用は3レベルまで
    )
    SELECT * FROM referral_tree
    ORDER BY level_num, user_id;
END;
$$;


ALTER FUNCTION "public"."get_referral_tree_user"("root_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_system_logs"("p_limit" integer DEFAULT 100, "p_log_type" "text" DEFAULT NULL::"text", "p_operation" "text" DEFAULT NULL::"text") RETURNS TABLE("id" "uuid", "log_type" "text", "operation" "text", "user_id" "text", "details" "jsonb", "message" "text", "ip_address" "text", "user_agent" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sl.id,
        sl.log_type,
        sl.operation,
        sl.user_id,
        sl.details,
        sl.message,
        sl.ip_address,
        sl.user_agent,
        sl.created_at
    FROM system_logs sl
    WHERE 
        (p_log_type IS NULL OR sl.log_type = p_log_type)
        AND (p_operation IS NULL OR sl.operation = p_operation)
    ORDER BY sl.created_at DESC
    LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_system_logs"("p_limit" integer, "p_log_type" "text", "p_operation" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_system_stats"() RETURNS TABLE("total_users" integer, "users_with_referrer" integer, "users_with_coinw" integer, "success_rate" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_users,
        COUNT(u.referrer_user_id)::INTEGER as users_with_referrer,
        COUNT(u.coinw_uid)::INTEGER as users_with_coinw,
        COALESCE(
            ROUND(
                (COUNT(CASE WHEN u.referrer_user_id IS NOT NULL AND u.coinw_uid IS NOT NULL THEN 1 END) * 100.0 / NULLIF(COUNT(*), 0))
            )::INTEGER, 
            0
        ) as success_rate
    FROM public.users u;
END;
$$;


ALTER FUNCTION "public"."get_system_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_daily_profit_stats"("p_user_id" "text", "p_days" integer DEFAULT 30) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_result JSON;
BEGIN
    -- ユーザー本人または管理者のみアクセス可能
    IF p_user_id != auth.uid()::text AND NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Access denied';
    END IF;
    
    SELECT json_build_object(
        'daily_profits', json_agg(
            json_build_object(
                'date', date,
                'yield_rate', yield_rate_percent,
                'daily_profit', daily_profit,
                'referral_reward', referral_reward,
                'total_reward', total_daily_reward
            ) ORDER BY date DESC
        ),
        'summary', json_build_object(
            'total_days', COUNT(*),
            'total_profit', SUM(daily_profit),
            'total_referral', SUM(referral_reward),
            'total_rewards', SUM(total_daily_reward),
            'avg_daily_profit', AVG(daily_profit),
            'max_daily_profit', MAX(daily_profit),
            'min_daily_profit', MIN(daily_profit)
        )
    )
    INTO v_result
    FROM user_daily_profit_history
    WHERE user_id = p_user_id 
      AND date >= CURRENT_DATE - INTERVAL '%s days' % p_days;
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."get_user_daily_profit_stats"("p_user_id" "text", "p_days" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_daily_profit_stats"("p_user_id" "text", "p_days" integer) IS 'ユーザー日利統計取得関数';



CREATE OR REPLACE FUNCTION "public"."get_user_deletion_info"("target_user_id" character varying) RETURNS TABLE("user_id" character varying, "email" character varying, "total_purchases" numeric, "purchase_count" bigint, "referral_count" bigint, "referred_by_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.user_id::VARCHAR(6),
        u.email::VARCHAR(255),
        COALESCE(u.total_purchases, 0)::NUMERIC as total_purchases,
        COALESCE(purchase_stats.purchase_count, 0)::BIGINT as purchase_count,
        COALESCE(referral_stats.referral_count, 0)::BIGINT as referral_count,
        CASE WHEN u.referrer_user_id IS NOT NULL THEN 1 ELSE 0 END::BIGINT as referred_by_count
    FROM users u
    LEFT JOIN (
        SELECT 
            p.user_id,
            COUNT(*)::BIGINT as purchase_count
        FROM purchases p
        WHERE p.user_id = target_user_id
        GROUP BY p.user_id
    ) purchase_stats ON u.user_id = purchase_stats.user_id
    LEFT JOIN (
        SELECT 
            r.referrer_user_id,
            COUNT(*)::BIGINT as referral_count
        FROM users r
        WHERE r.referrer_user_id = target_user_id
        GROUP BY r.referrer_user_id
    ) referral_stats ON u.user_id = referral_stats.referrer_user_id
    WHERE u.user_id = target_user_id;
END;
$$;


ALTER FUNCTION "public"."get_user_deletion_info"("target_user_id" character varying) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_emails"("p_user_email" "text") RETURNS TABLE("email_id" "uuid", "subject" "text", "body" "text", "from_name" "text", "status" "text", "created_at" timestamp with time zone, "sent_at" timestamp with time zone, "read_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id TEXT;
BEGIN
    -- ユーザーIDを取得
    SELECT user_id INTO v_user_id
    FROM users
    WHERE email = p_user_email;

    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'ユーザーが見つかりません';
    END IF;

    RETURN QUERY
    SELECT
        se.id as email_id,
        se.subject,
        se.body,
        se.from_name,
        er.status,
        se.created_at,
        er.sent_at,
        er.read_at
    FROM email_recipients er
    INNER JOIN system_emails se ON er.email_id = se.id
    WHERE er.user_id = v_user_id
    ORDER BY se.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_user_emails"("p_user_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_monthly_summary"("p_user_id" "text") RETURNS TABLE("month" "text", "total_daily_profit" numeric, "total_referral_reward" numeric, "total_reward" numeric, "payment_status" "text", "payment_date" "text", "transaction_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        TO_CHAR(udp.profit_date, 'YYYY-MM') as month,
        COALESCE(SUM(udp.daily_profit), 0)::DECIMAL as total_daily_profit,
        COALESCE(SUM(udp.referral_reward), 0)::DECIMAL as total_referral_reward,
        COALESCE(SUM(udp.daily_profit), 0)::DECIMAL + COALESCE(SUM(udp.referral_reward), 0)::DECIMAL as total_reward,
        'pending'::TEXT as payment_status,
        NULL::TEXT as payment_date,
        NULL::TEXT as transaction_id
    FROM user_daily_profit udp
    WHERE udp.user_id = p_user_id
    GROUP BY TO_CHAR(udp.profit_date, 'YYYY-MM')
    ORDER BY month DESC;
END;
$$;


ALTER FUNCTION "public"."get_user_monthly_summary"("p_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_stats"("target_user_id" "text") RETURNS TABLE("total_investment" numeric, "direct_referrals" integer, "total_referrals" integer, "level1_investment" numeric, "level2_investment" numeric, "level3_investment" numeric, "level4_plus_referrals" integer, "level4_plus_investment" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    WITH RECURSIVE referral_tree AS (
        -- レベル1: 直接紹介者
        SELECT 
            u.user_id,
            u.total_purchases,
            1 as level_num
        FROM users u 
        WHERE u.referrer_user_id = target_user_id
        
        UNION ALL
        
        -- レベル2以降: 間接紹介者（無制限、ただし安全のため最大50階層）
        SELECT 
            u.user_id,
            u.total_purchases,
            rt.level_num + 1
        FROM users u
        INNER JOIN referral_tree rt ON u.referrer_user_id = rt.user_id
        WHERE rt.level_num < 50  -- 無限ループ防止のため50階層まで
    ),
    level_stats AS (
        SELECT 
            level_num,
            COUNT(*) as user_count,
            SUM(FLOOR(COALESCE(total_purchases, 0) / 1100) * 1000) as investment_amount
        FROM referral_tree
        GROUP BY level_num
    )
    SELECT 
        -- 本人の投資額
        FLOOR(COALESCE((SELECT total_purchases FROM users WHERE user_id = target_user_id), 0) / 1100) * 1000 as total_investment,
        -- 直接紹介者数
        COALESCE((SELECT user_count FROM level_stats WHERE level_num = 1), 0)::INTEGER as direct_referrals,
        -- 総紹介者数（すべての階層）
        COALESCE((SELECT SUM(user_count) FROM level_stats), 0)::INTEGER as total_referrals,
        -- Level1投資額
        COALESCE((SELECT investment_amount FROM level_stats WHERE level_num = 1), 0) as level1_investment,
        -- Level2投資額
        COALESCE((SELECT investment_amount FROM level_stats WHERE level_num = 2), 0) as level2_investment,
        -- Level3投資額
        COALESCE((SELECT investment_amount FROM level_stats WHERE level_num = 3), 0) as level3_investment,
        -- Level4以降の人数（すべて）
        COALESCE((SELECT SUM(user_count) FROM level_stats WHERE level_num >= 4), 0)::INTEGER as level4_plus_referrals,
        -- Level4以降の投資額合計（すべて）
        COALESCE((SELECT SUM(investment_amount) FROM level_stats WHERE level_num >= 4), 0) as level4_plus_investment;
END;
$$;


ALTER FUNCTION "public"."get_user_stats"("target_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_yield_posting_history"("p_limit" integer DEFAULT 30) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_result JSON;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    SELECT json_agg(
        json_build_object(
            'date', dyl.date,
            'yield_rate', dyl.yield_rate,
            'margin_rate', dyl.margin_rate,
            'user_rate', dyl.user_rate,
            'is_month_end', dyl.is_month_end,
            'created_at', dyl.created_at,
            'created_by', dyl.created_by,
            'users_affected', cdp.user_count,
            'total_user_profit', cdp.total_user_profit,
            'total_company_profit', cdp.total_company_profit,
            'can_cancel', (dyl.date >= CURRENT_DATE - INTERVAL '7 days') -- 7日以内は取消可能
        ) ORDER BY dyl.date DESC
    )
    INTO v_result
    FROM daily_yield_log dyl
    LEFT JOIN company_daily_profit cdp ON dyl.date = cdp.date
    ORDER BY dyl.date DESC
    LIMIT p_limit;
    
    RETURN COALESCE(v_result, '[]'::json);
END;
$$;


ALTER FUNCTION "public"."get_yield_posting_history"("p_limit" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_yield_posting_history"("p_limit" integer) IS '日利投稿履歴を取得';



CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    new_user_id TEXT;
    referrer_id TEXT;
    coinw_uid_value TEXT;
    meta_data JSONB;
    existing_count INTEGER;
BEGIN
    -- デバッグログ開始
    RAISE NOTICE 'handle_new_user triggered for email: %', NEW.email;
    
    -- メタデータを取得
    meta_data := COALESCE(NEW.raw_user_meta_data, '{}'::jsonb);
    RAISE NOTICE 'Raw metadata: %', meta_data::text;
    
    -- 複数のキーからデータを取得
    referrer_id := COALESCE(
        meta_data->>'referrer_user_id',
        meta_data->>'referrer',
        meta_data->>'ref',
        meta_data->>'referrer_code',
        meta_data->>'referrer_id'
    );
    
    coinw_uid_value := COALESCE(
        meta_data->>'coinw_uid',
        meta_data->>'coinw',
        meta_data->>'uid',
        meta_data->>'coinw_id'
    );
    
    RAISE NOTICE 'Extracted - referrer: %, coinw_uid: %', referrer_id, coinw_uid_value;
    
    -- 既存のレコードをチェック
    SELECT COUNT(*) INTO existing_count 
    FROM public.users 
    WHERE id = NEW.id OR email = NEW.email;
    
    IF existing_count > 0 THEN
        RAISE NOTICE 'User already exists, updating instead of inserting';
        
        -- 既存レコードを更新
        UPDATE public.users 
        SET 
            referrer_user_id = CASE 
                WHEN referrer_id IS NOT NULL AND referrer_id != '' 
                THEN referrer_id 
                ELSE referrer_user_id 
            END,
            coinw_uid = CASE 
                WHEN coinw_uid_value IS NOT NULL AND coinw_uid_value != '' 
                THEN coinw_uid_value 
                ELSE coinw_uid 
            END,
            updated_at = NOW()
        WHERE id = NEW.id OR email = NEW.email;
        
        RAISE NOTICE 'User updated successfully';
        RETURN NEW;
    END IF;
    
    -- ランダムな6文字のuser_idを生成（重複チェック付き）
    LOOP
        new_user_id := upper(substring(md5(random()::text) from 1 for 6));
        EXIT WHEN NOT EXISTS (SELECT 1 FROM public.users WHERE user_id = new_user_id);
    END LOOP;
    
    RAISE NOTICE 'Generated user_id: %', new_user_id;
    
    -- 新しいレコードを挿入
    INSERT INTO public.users (
        id,
        user_id,
        email,
        referrer_user_id,
        coinw_uid,
        total_purchases,
        total_referral_earnings,
        is_active,
        has_approved_nft,
        created_at,
        updated_at
    ) VALUES (
        NEW.id,
        new_user_id,
        NEW.email,
        CASE 
            WHEN referrer_id IS NOT NULL AND referrer_id != '' 
            THEN referrer_id 
            ELSE NULL 
        END,
        CASE 
            WHEN coinw_uid_value IS NOT NULL AND coinw_uid_value != '' 
            THEN coinw_uid_value 
            ELSE NULL 
        END,
        0,
        0,
        true,
        false,
        NOW(),
        NOW()
    );
    
    RAISE NOTICE 'User created successfully: user_id=%, referrer=%, coinw_uid=%', 
        new_user_id, referrer_id, coinw_uid_value;
    
    RETURN NEW;
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'handle_new_user error for %: %', NEW.email, SQLERRM;
        -- エラーが発生してもトリガーは成功させる
        RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_complete"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    short_user_id TEXT;
    referrer_id TEXT;
    coinw_uid_value TEXT;
    full_name_value TEXT;
    retry_count INTEGER := 0;
    max_retries INTEGER := 3;
BEGIN
    -- ショートユーザーIDを生成
    short_user_id := generate_short_user_id();
    
    -- メタデータから値を確実に取得
    referrer_id := COALESCE(NEW.raw_user_meta_data->>'referrer_user_id', NULL);
    coinw_uid_value := COALESCE(NEW.raw_user_meta_data->>'coinw_uid', NULL);
    full_name_value := COALESCE(NEW.raw_user_meta_data->>'full_name', NULL);
    
    -- リトライ機能付きでusersテーブルに挿入
    WHILE retry_count < max_retries LOOP
        BEGIN
            INSERT INTO public.users (
                id,
                user_id,
                email,
                full_name,
                referrer_user_id,
                coinw_uid,
                created_at,
                updated_at,
                is_active,
                has_approved_nft,
                total_purchases,
                total_referral_earnings
            ) VALUES (
                NEW.id,
                short_user_id,
                NEW.email,
                full_name_value,
                referrer_id,
                coinw_uid_value,
                NOW(),
                NOW(),
                true,
                false,
                0,
                0
            );
            
            -- 成功したらログ出力してループを抜ける
            RAISE LOG 'Successfully created user: % with CoinW UID: %', short_user_id, coinw_uid_value;
            EXIT;
            
        EXCEPTION
            WHEN unique_violation THEN
                retry_count := retry_count + 1;
                short_user_id := generate_short_user_id();
                RAISE LOG 'Retry % for user creation due to unique violation', retry_count;
                
            WHEN OTHERS THEN
                RAISE LOG 'Error in handle_new_user_complete: %, retrying...', SQLERRM;
                retry_count := retry_count + 1;
        END;
    END LOOP;
    
    -- 最大リトライ回数に達した場合のエラーログ
    IF retry_count >= max_retries THEN
        RAISE LOG 'Failed to create user after % retries for email: %', max_retries, NEW.email;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_complete"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_registration"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    short_user_id TEXT;
    referrer_id TEXT;
    coinw_uid_value TEXT;
    full_name_value TEXT;
    retry_count INTEGER := 0;
    max_retries INTEGER := 3;
BEGIN
    -- 詳細なデバッグログ
    RAISE LOG 'Registration trigger fired for: %', NEW.email;
    RAISE LOG 'Full metadata received: %', NEW.raw_user_meta_data;
    
    -- ショートユーザーIDを生成
    short_user_id := generate_short_user_id();
    
    -- メタデータから値を取得（複数の方法で試行）
    referrer_id := COALESCE(
        NEW.raw_user_meta_data->>'referrer_user_id',
        NEW.raw_user_meta_data->>'ref',
        NEW.user_metadata->>'referrer_user_id'
    );
    
    coinw_uid_value := COALESCE(
        NEW.raw_user_meta_data->>'coinw_uid',
        NEW.raw_user_meta_data->>'coinw',
        NEW.user_metadata->>'coinw_uid'
    );
    
    full_name_value := COALESCE(
        NEW.raw_user_meta_data->>'full_name',
        NEW.user_metadata->>'full_name'
    );
    
    -- 取得した値をログ出力
    RAISE LOG 'Extracted values - referrer: %, coinw_uid: %, full_name: %', 
        referrer_id, coinw_uid_value, full_name_value;
    
    -- リトライ機能付きでusersテーブルに挿入
    WHILE retry_count < max_retries LOOP
        BEGIN
            INSERT INTO public.users (
                id,
                user_id,
                email,
                full_name,
                referrer_user_id,
                coinw_uid,
                created_at,
                updated_at,
                is_active,
                has_approved_nft,
                total_purchases,
                total_referral_earnings
            ) VALUES (
                NEW.id,
                short_user_id,
                NEW.email,
                full_name_value,
                referrer_id,
                coinw_uid_value,
                NOW(),
                NOW(),
                true,
                false,
                0,
                0
            );
            
            RAISE LOG 'Successfully created user: % with coinw_uid: % and referrer: %', 
                short_user_id, coinw_uid_value, referrer_id;
            EXIT;
            
        EXCEPTION
            WHEN unique_violation THEN
                retry_count := retry_count + 1;
                short_user_id := generate_short_user_id();
                RAISE LOG 'Retry % due to unique violation', retry_count;
                
            WHEN OTHERS THEN
                RAISE LOG 'Error in user creation: %, retrying...', SQLERRM;
                retry_count := retry_count + 1;
        END;
    END LOOP;
    
    IF retry_count >= max_retries THEN
        RAISE LOG 'CRITICAL: Failed to create user after % retries for: %', max_retries, NEW.email;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_registration"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_with_coinw_uid"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    short_user_id TEXT;
    referrer_id TEXT;
    coinw_uid_value TEXT;
    full_name_value TEXT;
    retry_count INTEGER := 0;
    max_retries INTEGER := 3;
BEGIN
    -- デバッグログ
    RAISE LOG 'New user trigger fired for email: %, metadata: %', NEW.email, NEW.raw_user_meta_data;
    
    -- ショートユーザーIDを生成
    short_user_id := generate_short_user_id();
    
    -- メタデータから値を確実に取得
    referrer_id := NEW.raw_user_meta_data->>'referrer_user_id';
    coinw_uid_value := NEW.raw_user_meta_data->>'coinw_uid';
    full_name_value := NEW.raw_user_meta_data->>'full_name';
    
    -- CoinW UIDの取得をログ出力
    RAISE LOG 'Extracted CoinW UID: % for user: %', coinw_uid_value, NEW.email;
    
    -- リトライ機能付きでusersテーブルに挿入
    WHILE retry_count < max_retries LOOP
        BEGIN
            INSERT INTO public.users (
                id,
                user_id,
                email,
                full_name,
                referrer_user_id,
                coinw_uid,
                created_at,
                updated_at,
                is_active,
                has_approved_nft,
                total_purchases,
                total_referral_earnings
            ) VALUES (
                NEW.id,
                short_user_id,
                NEW.email,
                full_name_value,
                referrer_id,
                coinw_uid_value,
                NOW(),
                NOW(),
                true,
                false,
                0,
                0
            );
            
            -- 成功ログ
            RAISE LOG 'Successfully created user: % with CoinW UID: % and referrer: %', 
                short_user_id, coinw_uid_value, referrer_id;
            EXIT;
            
        EXCEPTION
            WHEN unique_violation THEN
                retry_count := retry_count + 1;
                short_user_id := generate_short_user_id();
                RAISE LOG 'Retry % for user creation due to unique violation', retry_count;
                
            WHEN OTHERS THEN
                RAISE LOG 'Error in handle_new_user_with_coinw_uid: %, retrying...', SQLERRM;
                retry_count := retry_count + 1;
        END;
    END LOOP;
    
    -- 最大リトライ回数に達した場合のエラーログ
    IF retry_count >= max_retries THEN
        RAISE LOG 'CRITICAL: Failed to create user after % retries for email: %', max_retries, NEW.email;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_with_coinw_uid"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_with_metadata"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    short_user_id TEXT;
    referrer_id TEXT;
    coinw_uid_value TEXT;
BEGIN
    -- ショートユーザーIDを生成
    short_user_id := generate_short_user_id();
    
    -- メタデータからreferrer_user_idとcoinw_uidを取得
    referrer_id := NEW.raw_user_meta_data->>'referrer_user_id';
    coinw_uid_value := NEW.raw_user_meta_data->>'coinw_uid';
    
    -- デバッグログ
    RAISE LOG 'Creating user with CoinW UID: % for email: %', coinw_uid_value, NEW.email;
    
    -- usersテーブルにレコードを挿入
    INSERT INTO public.users (
        id,
        user_id,
        email,
        full_name,
        referrer_user_id,
        coinw_uid,
        created_at,
        updated_at,
        is_active
    ) VALUES (
        NEW.id,
        short_user_id,
        NEW.email,
        NEW.raw_user_meta_data->>'full_name',
        referrer_id,
        coinw_uid_value,
        NOW(),
        NOW(),
        true
    );
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE LOG 'Error in handle_new_user_with_metadata: %', SQLERRM;
        RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_user_with_metadata"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"("user_email" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM admins 
        WHERE email = user_email 
        AND is_active = true
    );
END;
$$;


ALTER FUNCTION "public"."is_admin"("user_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"("user_email" "text" DEFAULT NULL::"text", "user_uuid" "uuid" DEFAULT NULL::"uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  admin_exists BOOLEAN := FALSE;
  check_email TEXT;
  debug_info TEXT := '';
BEGIN
  -- user_emailが提供された場合はそれを使用
  IF user_email IS NOT NULL THEN
    check_email := user_email;
    debug_info := 'Using provided email: ' || user_email;
  -- user_uuidが提供された場合はauth.usersからemailを取得
  ELSIF user_uuid IS NOT NULL THEN
    SELECT email INTO check_email 
    FROM auth.users 
    WHERE id = user_uuid;
    debug_info := 'Retrieved email from UUID: ' || COALESCE(check_email, 'NOT_FOUND');
  -- どちらも提供されない場合は現在のユーザーのemailを使用
  ELSE
    SELECT email INTO check_email 
    FROM auth.users 
    WHERE id = auth.uid();
    debug_info := 'Using current user email: ' || COALESCE(check_email, 'NOT_FOUND');
  END IF;
  
  -- 管理者テーブルにユーザーが存在し、かつis_activeがtrueか確認
  IF check_email IS NOT NULL THEN
    SELECT EXISTS (
      SELECT 1 
      FROM admins 
      WHERE email = check_email
      AND is_active = true
    ) INTO admin_exists;
    
    -- デバッグログ（本番では削除）
    RAISE NOTICE 'is_admin debug - email: %, admin_exists: %, debug: %', check_email, admin_exists, debug_info;
  END IF;
  
  RETURN admin_exists;
END;
$$;


ALTER FUNCTION "public"."is_admin"("user_email" "text", "user_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_month_end"() RETURNS boolean
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT get_japan_date() = get_month_end(get_japan_date());
$$;


ALTER FUNCTION "public"."is_month_end"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_month_end_jst"() RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_today DATE;
    v_last_day DATE;
BEGIN
    -- 日本時間での現在日付を取得
    v_today := (NOW() AT TIME ZONE 'Asia/Tokyo')::DATE;
    
    -- 当月の最終日を取得
    v_last_day := DATE_TRUNC('month', v_today) + INTERVAL '1 month' - INTERVAL '1 day';
    
    RETURN v_today = v_last_day;
END;
$$;


ALTER FUNCTION "public"."is_month_end_jst"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_month_start"() RETURNS boolean
    LANGUAGE "sql" IMMUTABLE
    AS $$
    SELECT get_japan_date() = get_month_start(get_japan_date());
$$;


ALTER FUNCTION "public"."is_month_start"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_system_admin"("p_email" "text") RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    AS $$
    SELECT p_email IN ('basarasystems@gmail.com', 'support@dshsupport.biz');
$$;


ALTER FUNCTION "public"."is_system_admin"("p_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_user_admin"() RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    AS $$
    SELECT EXISTS (
        SELECT 1 FROM admins 
        WHERE user_id = auth.uid()::text
    )
    OR
    auth.email() IN ('basarasystems@gmail.com', 'support@dshsupport.biz', 'masataka.tak@gmail.com');
$$;


ALTER FUNCTION "public"."is_user_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_system_event"("p_log_type" "text", "p_operation" "text", "p_message" "text", "p_user_id" "text" DEFAULT NULL::"text", "p_details" "jsonb" DEFAULT NULL::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_log_id UUID;
BEGIN
    INSERT INTO system_logs (
        log_type,
        operation,
        user_id,
        message,
        details,
        created_at
    ) VALUES (
        p_log_type,
        p_operation,
        p_user_id,
        p_message,
        p_details,
        NOW()
    ) RETURNING id INTO v_log_id;
    
    RETURN v_log_id;
END;
$$;


ALTER FUNCTION "public"."log_system_event"("p_log_type" "text", "p_operation" "text", "p_message" "text", "p_user_id" "text", "p_details" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."manual_coinw_uid_sync"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    result_count INTEGER;
BEGIN
    SELECT sync_coinw_uid_from_auth() INTO result_count;
    RETURN format('CoinW UID同期完了: %s件のレコードを更新しました', result_count);
END;
$$;


ALTER FUNCTION "public"."manual_coinw_uid_sync"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_email_as_read"("p_email_id" "uuid", "p_user_email" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id TEXT;
BEGIN
    -- ユーザーIDを取得
    SELECT user_id INTO v_user_id
    FROM users
    WHERE email = p_user_email;

    IF v_user_id IS NULL THEN
        RAISE EXCEPTION 'ユーザーが見つかりません';
    END IF;

    -- メールを既読に更新
    UPDATE email_recipients
    SET status = 'read',
        read_at = NOW()
    WHERE email_id = p_email_id
    AND user_id = v_user_id
    AND status != 'read';

    RETURN json_build_object(
        'success', true,
        'message', 'メールを既読にしました'
    );
END;
$$;


ALTER FUNCTION "public"."mark_email_as_read"("p_email_id" "uuid", "p_user_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_nft_sent"("target_user_id" "text", "admin_email" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  result JSON;
BEGIN
  -- 管理者権限チェック
  IF NOT EXISTS (SELECT 1 FROM admins WHERE email = admin_email AND is_active = true) THEN
    RETURN json_build_object('success', false, 'message', '管理者権限がありません');
  END IF;

  -- NFT送付完了を記録
  UPDATE users 
  SET 
    nft_sent = true,
    nft_sent_at = NOW(),
    nft_sent_by = admin_email,
    updated_at = NOW()
  WHERE user_id = target_user_id;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'message', 'ユーザーが見つかりません');
  END IF;

  RETURN json_build_object('success', true, 'message', 'NFT送付完了を記録しました');
END;
$$;


ALTER FUNCTION "public"."mark_nft_sent"("target_user_id" "text", "admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_reward_as_paid"("p_user_id" "text", "p_year" integer, "p_month" integer, "p_transaction_id" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_result JSON;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    UPDATE user_monthly_rewards
    SET 
        is_paid = true,
        paid_at = NOW(),
        paid_by = auth.uid()::text,
        payment_transaction_id = p_transaction_id,
        updated_at = NOW()
    WHERE user_id = p_user_id AND year = p_year AND month = p_month;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Reward record not found';
    END IF;
    
    v_result := json_build_object(
        'success', true,
        'message', 'Payment marked as completed'
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."mark_reward_as_paid"("p_user_id" "text", "p_year" integer, "p_month" integer, "p_transaction_id" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."mark_reward_as_paid"("p_user_id" "text", "p_year" integer, "p_month" integer, "p_transaction_id" "text") IS '報酬支払い完了マーク関数';



CREATE OR REPLACE FUNCTION "public"."modify_yield_posting"("p_date" "date", "p_new_yield_rate" numeric, "p_new_margin_rate" numeric, "p_new_is_month_end" boolean DEFAULT false) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_result JSON;
BEGIN
    -- 管理者権限チェック
    IF NOT EXISTS (SELECT 1 FROM admins WHERE user_id = auth.uid()::text) THEN
        RAISE EXCEPTION 'Admin access required';
    END IF;
    
    -- 既存の日利投稿があるかチェック
    IF NOT EXISTS (SELECT 1 FROM daily_yield_log WHERE date = p_date) THEN
        RAISE EXCEPTION '指定日の日利投稿が見つかりません: %', p_date;
    END IF;
    
    -- 既存データを削除してから新しいデータで再計算
    PERFORM cancel_yield_posting(p_date);
    
    -- 新しい設定で再投稿
    SELECT admin_post_yield(p_date, p_new_yield_rate, p_new_margin_rate, p_new_is_month_end)
    INTO v_result;
    
    -- 結果に修正情報を追加
    v_result := v_result || json_build_object(
        'modified', true,
        'original_action', 'modify_yield_posting',
        'modified_by', auth.uid(),
        'modified_at', NOW()
    );
    
    RETURN v_result;
END;
$$;


ALTER FUNCTION "public"."modify_yield_posting"("p_date" "date", "p_new_yield_rate" numeric, "p_new_margin_rate" numeric, "p_new_is_month_end" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."modify_yield_posting"("p_date" "date", "p_new_yield_rate" numeric, "p_new_margin_rate" numeric, "p_new_is_month_end" boolean) IS '日利投稿を修正（取消してから再投稿）';



CREATE OR REPLACE FUNCTION "public"."process_buyback_request"("p_request_id" "uuid", "p_action" "text", "p_transaction_hash" "text" DEFAULT NULL::"text", "p_admin_notes" "text" DEFAULT NULL::"text", "p_admin_email" "text" DEFAULT NULL::"text") RETURNS TABLE("status" "text", "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_request_record RECORD;
    v_nft_record RECORD;
    v_count_manual INTEGER := 0;
    v_count_auto INTEGER := 0;
BEGIN
    -- 買い取り申請を取得
    SELECT * INTO v_request_record
    FROM buyback_requests
    WHERE id = p_request_id;

    IF NOT FOUND THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            '買い取り申請が見つかりません'::TEXT;
        RETURN;
    END IF;

    IF v_request_record.status != 'pending' THEN
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            FORMAT('この申請は既に処理されています（ステータス: %s）', v_request_record.status)::TEXT;
        RETURN;
    END IF;

    IF p_action = 'complete' THEN
        -- 承認処理: NFTのbuyback_dateを設定（古い順に選択）

        -- 手動NFT
        v_count_manual := 0;
        FOR v_nft_record IN
            SELECT id
            FROM nft_master
            WHERE user_id = v_request_record.user_id
              AND nft_type = 'manual'
              AND buyback_date IS NULL
            ORDER BY nft_sequence ASC
            LIMIT v_request_record.manual_nft_count
        LOOP
            UPDATE nft_master
            SET buyback_date = CURRENT_DATE,
                updated_at = NOW()
            WHERE id = v_nft_record.id;

            v_count_manual := v_count_manual + 1;
        END LOOP;

        -- 自動NFT
        v_count_auto := 0;
        FOR v_nft_record IN
            SELECT id
            FROM nft_master
            WHERE user_id = v_request_record.user_id
              AND nft_type = 'auto'
              AND buyback_date IS NULL
            ORDER BY nft_sequence ASC
            LIMIT v_request_record.auto_nft_count
        LOOP
            UPDATE nft_master
            SET buyback_date = CURRENT_DATE,
                updated_at = NOW()
            WHERE id = v_nft_record.id;

            v_count_auto := v_count_auto + 1;
        END LOOP;

        -- ⭐ 修正: affiliate_cycleを更新（NFT枚数を減らす）
        UPDATE affiliate_cycle
        SET
            manual_nft_count = manual_nft_count - v_count_manual,
            auto_nft_count = auto_nft_count - v_count_auto,
            total_nft_count = total_nft_count - (v_count_manual + v_count_auto),
            last_updated = NOW()
        WHERE user_id = v_request_record.user_id;

        -- 買い取り申請を完了に更新
        UPDATE buyback_requests
        SET
            status = 'completed',
            processed_at = NOW(),
            processed_by = p_admin_email,
            transaction_hash = p_transaction_hash
        WHERE id = p_request_id;

        RETURN QUERY SELECT
            'SUCCESS'::TEXT,
            FORMAT('買い取り申請を承認しました（手動: %s枚, 自動: %s枚）',
                v_count_manual, v_count_auto)::TEXT;

    ELSIF p_action = 'cancel' THEN
        -- キャンセル処理
        UPDATE buyback_requests
        SET
            status = 'cancelled',
            processed_at = NOW(),
            processed_by = p_admin_email
        WHERE id = p_request_id;

        RETURN QUERY SELECT
            'SUCCESS'::TEXT,
            '買い取り申請をキャンセルしました'::TEXT;

    ELSE
        RETURN QUERY SELECT
            'ERROR'::TEXT,
            FORMAT('無効なアクション: %s', p_action)::TEXT;
    END IF;
END;
$$;


ALTER FUNCTION "public"."process_buyback_request"("p_request_id" "uuid", "p_action" "text", "p_transaction_hash" "text", "p_admin_notes" "text", "p_admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_daily_yield_with_cycles"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric DEFAULT 30.0, "p_is_test_mode" boolean DEFAULT true, "p_skip_validation" boolean DEFAULT false) RETURNS TABLE("status" "text", "total_users" integer, "total_user_profit" numeric, "total_company_profit" numeric, "cycle_updates" integer, "auto_nft_purchases" integer, "referral_rewards_processed" integer, "monthly_withdrawals_processed" integer, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_count INTEGER := 0;
    v_total_user_profit NUMERIC := 0;
    v_total_company_profit NUMERIC := 0;
    v_cycle_updates INTEGER := 0;
    v_auto_purchases INTEGER := 0;
    v_referral_count INTEGER := 0;
    v_monthly_withdrawal_count INTEGER := 0;
    v_user_rate NUMERIC;
    v_after_margin NUMERIC;
    v_nft_record RECORD;
    v_nft_profit NUMERIC;
    v_company_profit NUMERIC;
    v_user_record RECORD;
    v_user_profit NUMERIC;
    v_base_amount NUMERIC;
    v_referral_profit NUMERIC;
    v_level_rate NUMERIC;
    v_child_record RECORD;
    v_is_month_end BOOLEAN;
    v_start_time TIMESTAMPTZ;
    v_end_time TIMESTAMPTZ;
    v_processing_time INTERVAL;
BEGIN
    v_start_time := NOW();
    v_is_month_end := is_month_end();

    -- パーセント値を割合に変換
    v_after_margin := (p_yield_rate / 100) * (1 - p_margin_rate / 100);
    v_user_rate := v_after_margin * 0.6;

    IF NOT p_is_test_mode THEN
        INSERT INTO daily_yield_log (date, yield_rate, margin_rate, user_rate, created_at)
        VALUES (p_date, p_yield_rate, p_margin_rate, v_user_rate, NOW())
        ON CONFLICT (date) DO UPDATE SET
            yield_rate = EXCLUDED.yield_rate,
            margin_rate = EXCLUDED.margin_rate,
            user_rate = EXCLUDED.user_rate,
            created_at = NOW();
    END IF;

    -- ⭐ STEP 1: 各NFTの日利を計算（個人利益 - ペガサス交換ユーザーを除外）
    FOR v_nft_record IN
        SELECT nm.id as nft_id, nm.user_id, nm.nft_type, nm.nft_value
        FROM nft_master nm
        INNER JOIN users u ON nm.user_id = u.user_id
        WHERE nm.buyback_date IS NULL
        AND COALESCE(u.is_pegasus_exchange, FALSE) = FALSE  -- ⭐ ペガサス除外
    LOOP
        v_nft_profit := v_nft_record.nft_value * v_user_rate;
        v_company_profit := v_nft_record.nft_value * (p_yield_rate / 100) - v_nft_profit;
        v_total_user_profit := v_total_user_profit + v_nft_profit;
        v_total_company_profit := v_total_company_profit + v_company_profit;

        IF NOT p_is_test_mode THEN
            INSERT INTO nft_daily_profit (nft_id, user_id, date, daily_profit, yield_rate, created_at)
            VALUES (v_nft_record.nft_id, v_nft_record.user_id, p_date, v_nft_profit, p_yield_rate, NOW())
            ON CONFLICT (nft_id, date) DO UPDATE SET
                daily_profit = EXCLUDED.daily_profit, yield_rate = EXCLUDED.yield_rate, created_at = NOW();
        END IF;
    END LOOP;

    -- ⭐ STEP 2: ユーザーごとに集計（個人利益 - ペガサス交換ユーザーを除外）
    FOR v_user_record IN
        SELECT u.user_id, u.has_approved_nft, u.operation_start_date,
               COALESCE(SUM(nm.nft_value), 0) as total_nft_value,
               COALESCE(ac.cum_usdt, 0) as cum_usdt, COALESCE(ac.available_usdt, 0) as available_usdt,
               COALESCE(ac.phase, 'USDT') as phase, COALESCE(ac.auto_nft_count, 0) as auto_nft_count,
               COALESCE(ac.manual_nft_count, 0) as manual_nft_count
        FROM users u
        LEFT JOIN nft_master nm ON u.user_id = nm.user_id AND nm.buyback_date IS NULL
        LEFT JOIN affiliate_cycle ac ON u.user_id = ac.user_id
        WHERE u.has_approved_nft = true
        AND (u.operation_start_date IS NULL OR u.operation_start_date <= p_date)
        AND COALESCE(u.is_pegasus_exchange, FALSE) = FALSE  -- ⭐ ペガサス除外
        GROUP BY u.user_id, u.has_approved_nft, u.operation_start_date,
                 ac.cum_usdt, ac.available_usdt, ac.phase, ac.auto_nft_count, ac.manual_nft_count
    LOOP
        v_user_count := v_user_count + 1;
        v_base_amount := v_user_record.total_nft_value;
        v_user_profit := v_base_amount * v_user_rate;

        IF NOT p_is_test_mode THEN
            -- available_usdtに個人利益を加算（マイナスも含む）
            INSERT INTO affiliate_cycle (user_id, cum_usdt, available_usdt, phase, auto_nft_count, manual_nft_count, created_at, updated_at)
            VALUES (v_user_record.user_id, 0, v_user_profit, 'USDT', 0, 0, NOW(), NOW())
            ON CONFLICT (user_id) DO UPDATE SET
                available_usdt = affiliate_cycle.available_usdt + EXCLUDED.available_usdt, updated_at = NOW();
            v_cycle_updates := v_cycle_updates + 1;
        END IF;
    END LOOP;

    -- ⭐ STEP 3: 紹介報酬（マイナス日利時は0、全ユーザー対象）
    IF p_yield_rate > 0 THEN
        FOR v_user_record IN
            SELECT u.user_id, u.has_approved_nft, u.operation_start_date,
                   COALESCE(SUM(nm.nft_value), 0) as total_nft_value
            FROM users u
            LEFT JOIN nft_master nm ON u.user_id = nm.user_id AND nm.buyback_date IS NULL
            WHERE u.has_approved_nft = true
            AND (u.operation_start_date IS NULL OR u.operation_start_date <= p_date)
            -- ⭐ ペガサス交換ユーザーも紹介報酬の対象（紹介者が受け取る）
            GROUP BY u.user_id, u.has_approved_nft, u.operation_start_date
        LOOP
            v_user_profit := v_user_record.total_nft_value * v_user_rate;

            -- レベル1: 20%
            FOR v_child_record IN
                SELECT DISTINCT u2.user_id as parent_id
                FROM users u2
                WHERE u2.referrer_user_id = v_user_record.user_id
                AND u2.has_approved_nft = true
                AND (u2.operation_start_date IS NULL OR u2.operation_start_date <= p_date)
            LOOP
                v_referral_profit := v_user_profit * 0.20;
                IF NOT p_is_test_mode THEN
                    INSERT INTO user_referral_profit (user_id, child_user_id, date, referral_level, profit_amount, created_at)
                    VALUES (v_child_record.parent_id, v_user_record.user_id, p_date, 1, v_referral_profit, NOW())
                    ON CONFLICT (user_id, date, referral_level, child_user_id) DO UPDATE SET
                        profit_amount = EXCLUDED.profit_amount, created_at = NOW();

                    INSERT INTO affiliate_cycle (user_id, cum_usdt, available_usdt, phase, auto_nft_count, manual_nft_count, created_at, updated_at)
                    VALUES (v_child_record.parent_id, v_referral_profit, 0, 'USDT', 0, 0, NOW(), NOW())
                    ON CONFLICT (user_id) DO UPDATE SET
                        cum_usdt = affiliate_cycle.cum_usdt + EXCLUDED.cum_usdt, updated_at = NOW();
                END IF;
                v_referral_count := v_referral_count + 1;
            END LOOP;

            -- レベル2: 10%
            FOR v_child_record IN
                SELECT DISTINCT u3.user_id as parent_id
                FROM users u2
                INNER JOIN users u3 ON u2.referrer_user_id = u3.user_id
                WHERE u2.referrer_user_id = v_user_record.user_id
                AND u3.has_approved_nft = true
                AND (u3.operation_start_date IS NULL OR u3.operation_start_date <= p_date)
            LOOP
                v_referral_profit := v_user_profit * 0.10;
                IF NOT p_is_test_mode THEN
                    INSERT INTO user_referral_profit (user_id, child_user_id, date, referral_level, profit_amount, created_at)
                    VALUES (v_child_record.parent_id, v_user_record.user_id, p_date, 2, v_referral_profit, NOW())
                    ON CONFLICT (user_id, date, referral_level, child_user_id) DO UPDATE SET
                        profit_amount = EXCLUDED.profit_amount, created_at = NOW();

                    INSERT INTO affiliate_cycle (user_id, cum_usdt, available_usdt, phase, auto_nft_count, manual_nft_count, created_at, updated_at)
                    VALUES (v_child_record.parent_id, v_referral_profit, 0, 'USDT', 0, 0, NOW(), NOW())
                    ON CONFLICT (user_id) DO UPDATE SET
                        cum_usdt = affiliate_cycle.cum_usdt + EXCLUDED.cum_usdt, updated_at = NOW();
                END IF;
                v_referral_count := v_referral_count + 1;
            END LOOP;

            -- レベル3: 5%
            FOR v_child_record IN
                SELECT DISTINCT u4.user_id as parent_id
                FROM users u2
                INNER JOIN users u3 ON u2.referrer_user_id = u3.user_id
                INNER JOIN users u4 ON u3.referrer_user_id = u4.user_id
                WHERE u2.referrer_user_id = v_user_record.user_id
                AND u4.has_approved_nft = true
                AND (u4.operation_start_date IS NULL OR u4.operation_start_date <= p_date)
            LOOP
                v_referral_profit := v_user_profit * 0.05;
                IF NOT p_is_test_mode THEN
                    INSERT INTO user_referral_profit (user_id, child_user_id, date, referral_level, profit_amount, created_at)
                    VALUES (v_child_record.parent_id, v_user_record.user_id, p_date, 3, v_referral_profit, NOW())
                    ON CONFLICT (user_id, date, referral_level, child_user_id) DO UPDATE SET
                        profit_amount = EXCLUDED.profit_amount, created_at = NOW();

                    INSERT INTO affiliate_cycle (user_id, cum_usdt, available_usdt, phase, auto_nft_count, manual_nft_count, created_at, updated_at)
                    VALUES (v_child_record.parent_id, v_referral_profit, 0, 'USDT', 0, 0, NOW(), NOW())
                    ON CONFLICT (user_id) DO UPDATE SET
                        cum_usdt = affiliate_cycle.cum_usdt + EXCLUDED.cum_usdt, updated_at = NOW();
                END IF;
                v_referral_count := v_referral_count + 1;
            END LOOP;
        END LOOP;
    END IF;

    -- STEP 4: サイクル判定と自動NFT付与
    IF NOT p_is_test_mode THEN
        FOR v_user_record IN
            SELECT user_id, cum_usdt, auto_nft_count
            FROM affiliate_cycle
            WHERE cum_usdt >= 2200
        LOOP
            INSERT INTO nft_master (user_id, nft_type, nft_value, purchase_date, is_auto_purchase, cycle_number, created_at)
            VALUES (v_user_record.user_id, 'standard', 1000, p_date, TRUE, v_user_record.auto_nft_count + 1, NOW());

            INSERT INTO purchases (user_id, nft_quantity, amount_usd, payment_status, admin_approved,
                                   is_auto_purchase, cycle_number_at_purchase, created_at)
            VALUES (v_user_record.user_id, 1, 1100, 'completed', TRUE, TRUE, v_user_record.auto_nft_count + 1, NOW());

            UPDATE affiliate_cycle
            SET cum_usdt = cum_usdt - 2200, available_usdt = available_usdt + 1100,
                auto_nft_count = auto_nft_count + 1,
                phase = CASE WHEN (cum_usdt - 2200) >= 1100 THEN 'HOLD' ELSE 'USDT' END,
                updated_at = NOW()
            WHERE user_id = v_user_record.user_id;

            v_auto_purchases := v_auto_purchases + 1;
        END LOOP;
    END IF;

    -- STEP 5: 月末出金処理
    IF v_is_month_end AND NOT p_is_test_mode THEN
        SELECT COUNT(*) INTO v_monthly_withdrawal_count
        FROM process_monthly_withdrawals(p_date);
    END IF;

    v_end_time := NOW();
    v_processing_time := v_end_time - v_start_time;

    RETURN QUERY SELECT
        'success'::text, v_user_count, v_total_user_profit, v_total_company_profit,
        v_cycle_updates, v_auto_purchases, v_referral_count, v_monthly_withdrawal_count,
        format('処理完了: ユーザー数=%s, サイクル更新=%s, 自動NFT付与=%s, 紹介報酬=%s（マイナス日利時は0、ペガサス除外）, 月次出金=%s, 処理時間=%s',
            v_user_count, v_cycle_updates, v_auto_purchases, v_referral_count,
            v_monthly_withdrawal_count, v_processing_time)::text;
END;
$$;


ALTER FUNCTION "public"."process_daily_yield_with_cycles"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean, "p_skip_validation" boolean) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."process_daily_yield_with_cycles"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean, "p_skip_validation" boolean) IS '日利処理（ペガサス交換ユーザーは個人利益なし、紹介報酬のみ）';



CREATE OR REPLACE FUNCTION "public"."process_monthly_auto_withdrawal"() RETURNS TABLE("processed_count" integer, "total_amount" numeric, "nft_purchases" integer, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
    v_processed_count INTEGER := 0;
    v_total_amount NUMERIC := 0;
    v_nft_purchases INTEGER := 0;
    v_today DATE;
    v_last_day DATE;
    v_user_record RECORD;
BEGIN
    -- 日本時間での現在日付を取得
    v_today := (NOW() AT TIME ZONE 'Asia/Tokyo')::DATE;

    -- 当月の最終日を取得
    v_last_day := DATE_TRUNC('month', v_today) + INTERVAL '1 month' - INTERVAL '1 day';

    -- 今日が月末でない場合はエラー
    IF v_today != v_last_day THEN
        RETURN QUERY
        SELECT
            0::INTEGER,
            0::NUMERIC,
            0::INTEGER,
            '本日は月末ではありません。処理をスキップします。'::TEXT;
        RETURN;
    END IF;

    -- STEP 1: NFT強制購入処理（cum_usdt >= 2200のユーザー）
    FOR v_user_record IN
        SELECT
            ac.user_id,
            u.email,
            ac.cum_usdt,
            ac.total_nft_count,
            ac.auto_nft_count
        FROM affiliate_cycle ac
        JOIN users u ON ac.user_id = u.user_id
        WHERE ac.cum_usdt >= 2200
    LOOP
        -- NFT購入数を計算（2200 USDTごとに1つ）
        DECLARE
            v_nft_to_purchase INTEGER;
            v_remaining_usdt NUMERIC;
        BEGIN
            v_nft_to_purchase := FLOOR(v_user_record.cum_usdt / 2200);
            v_remaining_usdt := v_user_record.cum_usdt - (v_nft_to_purchase * 2200);

            -- NFT購入処理
            UPDATE affiliate_cycle
            SET
                total_nft_count = total_nft_count + v_nft_to_purchase,
                auto_nft_count = auto_nft_count + v_nft_to_purchase,
                cum_usdt = v_remaining_usdt,
                available_usdt = available_usdt + (v_nft_to_purchase * 1100), -- 各NFTで1100 USDT受取
                phase = CASE
                    WHEN v_remaining_usdt >= 1100 THEN 'HOLD'
                    ELSE 'USDT'
                END,
                last_updated = NOW()
            WHERE user_id = v_user_record.user_id;

            -- 自動購入履歴に記録
            IF v_nft_to_purchase > 0 THEN
                INSERT INTO auto_purchase_history (
                    user_id,
                    purchase_date,
                    nft_quantity,
                    cum_usdt_before,
                    cum_usdt_after,
                    created_at
                )
                VALUES (
                    v_user_record.user_id,
                    v_today,
                    v_nft_to_purchase,
                    v_user_record.cum_usdt,
                    v_remaining_usdt,
                    NOW()
                );

                v_nft_purchases := v_nft_purchases + v_nft_to_purchase;
            END IF;
        END;
    END LOOP;

    -- STEP 2: 出金処理（available_usdt >= 100のユーザー）
    -- ⭐ ペガサス交換ユーザーを除外
    FOR v_user_record IN
        SELECT
            ac.user_id,
            u.email,
            ac.available_usdt,
            uws.withdrawal_address,
            uws.coinw_uid
        FROM affiliate_cycle ac
        INNER JOIN users u ON ac.user_id = u.user_id
        LEFT JOIN user_withdrawal_settings uws ON ac.user_id = uws.user_id
        WHERE ac.available_usdt >= 100  -- 最低出金額100 USDT
          -- ⭐ ペガサス交換ユーザーで出金制限期間内のユーザーを除外
          AND NOT (
              COALESCE(u.is_pegasus_exchange, FALSE) = TRUE
              AND (
                  u.pegasus_withdrawal_unlock_date IS NULL
                  OR CURRENT_DATE < u.pegasus_withdrawal_unlock_date
              )
          )
          -- 同月の自動出金申請が既に存在しないかチェック
          AND NOT EXISTS (
              SELECT 1
              FROM withdrawals w
              WHERE w.user_id = ac.user_id
                AND w.withdrawal_type = 'monthly_auto'
                AND DATE_TRUNC('month', w.created_at AT TIME ZONE 'Asia/Tokyo') = DATE_TRUNC('month', v_today)
          )
    LOOP
        -- 出金申請を作成
        INSERT INTO withdrawals (
            user_id,
            email,
            amount,
            status,
            withdrawal_type,
            withdrawal_address,
            coinw_uid,
            created_at,
            notes
        )
        VALUES (
            v_user_record.user_id,
            v_user_record.email,
            v_user_record.available_usdt,
            'pending',
            'monthly_auto',
            v_user_record.withdrawal_address,
            v_user_record.coinw_uid,
            NOW(),
            '月末自動出金 - ' || TO_CHAR(v_today, 'YYYY年MM月')
        );

        -- available_usdtをリセット
        UPDATE affiliate_cycle
        SET
            available_usdt = 0,
            last_updated = NOW()
        WHERE user_id = v_user_record.user_id;

        v_processed_count := v_processed_count + 1;
        v_total_amount := v_total_amount + v_user_record.available_usdt;
    END LOOP;

    -- ログ記録
    BEGIN
        INSERT INTO system_logs (
            log_type,
            message,
            details,
            created_at
        )
        VALUES (
            'monthly_withdrawal',
            '月末処理完了: 出金' || v_processed_count || '件、NFT購入' || v_nft_purchases || '件',
            jsonb_build_object(
                'withdrawal_count', v_processed_count,
                'withdrawal_total', v_total_amount,
                'nft_purchases', v_nft_purchases,
                'process_date', v_today
            ),
            NOW()
        );
    EXCEPTION WHEN undefined_table THEN
        NULL;
    END;

    RETURN QUERY
    SELECT
        v_processed_count,
        v_total_amount,
        v_nft_purchases,
        ('月末処理が完了しました。出金申請: ' || v_processed_count || '件（総額: $' || v_total_amount || '）、NFT自動購入: ' || v_nft_purchases || '件')::TEXT;
END;
$_$;


ALTER FUNCTION "public"."process_monthly_auto_withdrawal"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_monthly_withdrawals"("p_target_month" "date" DEFAULT NULL::"date") RETURNS TABLE("processed_count" integer, "total_amount" numeric, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
    v_processed_count INTEGER := 0;
    v_total_amount NUMERIC := 0;
    v_target_month DATE;
    v_today DATE;
    v_last_day DATE;
    v_year INTEGER;
    v_month INTEGER;
    v_user_record RECORD;
BEGIN
    -- 日本時間での現在日付を取得
    v_today := (NOW() AT TIME ZONE 'Asia/Tokyo')::DATE;

    -- ターゲット月の設定（指定がなければ今月）
    IF p_target_month IS NULL THEN
        v_target_month := DATE_TRUNC('month', v_today)::DATE;
    ELSE
        v_target_month := DATE_TRUNC('month', p_target_month)::DATE;
    END IF;

    -- 月末日を計算
    v_last_day := (DATE_TRUNC('month', v_target_month) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;

    -- 今日が月末でない場合は警告（手動実行の場合は継続）
    IF v_today != v_last_day AND p_target_month IS NULL THEN
        RAISE NOTICE '⚠️ 本日（%）は月末（%）ではありません。手動実行として処理を継続します。', v_today, v_last_day;
    END IF;

    v_year := EXTRACT(YEAR FROM v_target_month);
    v_month := EXTRACT(MONTH FROM v_target_month);

    -- 出金処理（available_usdt >= 100のユーザー）
    -- ⭐ ペガサス交換ユーザーで出金制限期間内のユーザーを除外
    FOR v_user_record IN
        SELECT
            ac.user_id,
            u.email,
            ac.available_usdt,
            COALESCE(u.coinw_uid, '') as coinw_uid,
            COALESCE(u.nft_receive_address, '') as nft_receive_address,
            u.is_pegasus_exchange,
            u.pegasus_withdrawal_unlock_date
        FROM affiliate_cycle ac
        INNER JOIN users u ON ac.user_id = u.user_id
        WHERE ac.available_usdt >= 100  -- 最低出金額100 USDT
          -- ⭐ ペガサス交換ユーザーで出金制限期間内のユーザーを除外
          AND NOT (
              COALESCE(u.is_pegasus_exchange, FALSE) = TRUE
              AND (
                  u.pegasus_withdrawal_unlock_date IS NULL
                  OR CURRENT_DATE < u.pegasus_withdrawal_unlock_date
              )
          )
          -- 同月の出金申請が既に存在しないかチェック
          AND NOT EXISTS (
              SELECT 1
              FROM monthly_withdrawals mw
              WHERE mw.user_id = ac.user_id
                AND mw.withdrawal_month = v_target_month
          )
    LOOP
        -- 出金方法を決定
        DECLARE
            v_withdrawal_method TEXT;
            v_withdrawal_address TEXT;
            v_initial_status TEXT;
        BEGIN
            IF v_user_record.coinw_uid != '' THEN
                v_withdrawal_method := 'coinw';
                v_withdrawal_address := v_user_record.coinw_uid;
                v_initial_status := 'on_hold';  -- タスク未完了のため保留
            ELSIF v_user_record.nft_receive_address != '' THEN
                v_withdrawal_method := 'bep20';
                v_withdrawal_address := v_user_record.nft_receive_address;
                v_initial_status := 'on_hold';  -- タスク未完了のため保留
            ELSE
                v_withdrawal_method := NULL;
                v_withdrawal_address := NULL;
                v_initial_status := 'on_hold';  -- 設定なし＋タスク未完了
            END IF;

            -- 出金申請レコードを作成
            INSERT INTO monthly_withdrawals (
                user_id,
                email,
                withdrawal_month,
                total_amount,
                withdrawal_method,
                withdrawal_address,
                status,
                task_completed,
                created_at,
                updated_at
            )
            VALUES (
                v_user_record.user_id,
                v_user_record.email,
                v_target_month,
                v_user_record.available_usdt,
                v_withdrawal_method,
                v_withdrawal_address,
                v_initial_status,
                false,  -- タスク未完了
                NOW(),
                NOW()
            );

            -- 月末タスクレコードを作成
            INSERT INTO monthly_reward_tasks (
                user_id,
                year,
                month,
                is_completed,
                questions_answered,
                created_at,
                updated_at
            )
            VALUES (
                v_user_record.user_id,
                v_year,
                v_month,
                false,
                0,
                NOW(),
                NOW()
            )
            ON CONFLICT (user_id, year, month) DO NOTHING;

            v_processed_count := v_processed_count + 1;
            v_total_amount := v_total_amount + v_user_record.available_usdt;
        END;
    END LOOP;

    -- ログ記録
    BEGIN
        INSERT INTO system_logs (
            log_type,
            message,
            details,
            created_at
        )
        VALUES (
            'monthly_withdrawal',
            FORMAT('月末出金処理完了: %s年%s月 - 出金申請%s件作成', v_year, v_month, v_processed_count),
            jsonb_build_object(
                'year', v_year,
                'month', v_month,
                'withdrawal_count', v_processed_count,
                'withdrawal_total', v_total_amount,
                'process_date', v_today,
                'target_month', v_target_month
            ),
            NOW()
        );
    EXCEPTION WHEN undefined_table THEN
        NULL;
    END;

    RETURN QUERY
    SELECT
        v_processed_count,
        v_total_amount,
        CASE
            WHEN v_processed_count = 0 THEN
                FORMAT('月末出金処理が完了しました。%s年%s月分 - 新規出金申請: 0件（既に処理済みまたは対象ユーザーなし）', v_year, v_month)
            ELSE
                FORMAT('月末出金処理が完了しました。%s年%s月分 - 出金申請: %s件（総額: $%s）', v_year, v_month, v_processed_count, v_total_amount::TEXT)
        END;
END;
$_$;


ALTER FUNCTION "public"."process_monthly_withdrawals"("p_target_month" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_user_active_on_nft_purchase"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- 新しいNFTが作成されたとき、そのユーザーをアクティブに
    UPDATE users
    SET is_active_investor = TRUE
    WHERE user_id = NEW.user_id;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_user_active_on_nft_purchase"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."simple_admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean DEFAULT false) RETURNS TABLE("status" "text", "total_users" integer, "total_user_profit" numeric, "total_company_profit" numeric, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
  v_user_count INTEGER := 0;
  v_total_user_profit NUMERIC := 0;
  v_total_company_profit NUMERIC := 0;
  v_user_rate NUMERIC;
  v_user_record RECORD;
BEGIN
  -- ユーザー利率を計算
  v_user_rate := p_yield_rate * (1 - p_margin_rate) * 0.6;

  -- daily_yield_logに記録（重複時は更新）
  INSERT INTO daily_yield_log (
    date, yield_rate, margin_rate, user_rate, is_month_end, created_at
  )
  VALUES (
    p_date, p_yield_rate, p_margin_rate, v_user_rate, p_is_month_end, NOW()
  )
  ON CONFLICT (date) DO UPDATE SET
    yield_rate = EXCLUDED.yield_rate,
    margin_rate = EXCLUDED.margin_rate,
    user_rate = EXCLUDED.user_rate,
    is_month_end = EXCLUDED.is_month_end,
    created_at = NOW();

  -- user_daily_profitテーブルの既存データを削除
  DELETE FROM user_daily_profit WHERE date = p_date;

  -- 各ユーザーの利益を計算して挿入
  FOR v_user_record IN
    SELECT 
      user_id,
      total_nft_count,
      cum_usdt
    FROM affiliate_cycle 
    WHERE total_nft_count > 0
  LOOP
    DECLARE
      v_base_amount NUMERIC;
      v_daily_profit NUMERIC;
      v_company_profit NUMERIC;
    BEGIN
      -- 基準金額（NFT数 × 1100）
      v_base_amount := v_user_record.total_nft_count * 1100;
      
      -- ユーザー利益計算
      v_daily_profit := v_base_amount * v_user_rate;
      
      -- 会社利益計算
      v_company_profit := v_base_amount * p_margin_rate + v_base_amount * (p_yield_rate - p_margin_rate) * 0.1;

      -- user_daily_profitに挿入
      INSERT INTO user_daily_profit (
        user_id, date, daily_profit, yield_rate, user_rate, base_amount, phase, created_at
      )
      VALUES (
        v_user_record.user_id, p_date, v_daily_profit, p_yield_rate, v_user_rate, v_base_amount, 'USDT', NOW()
      );

      v_user_count := v_user_count + 1;
      v_total_user_profit := v_total_user_profit + v_daily_profit;
      v_total_company_profit := v_total_company_profit + v_company_profit;
    END;
  END LOOP;

  -- 結果を返す
  RETURN QUERY SELECT 
    'SUCCESS'::TEXT,
    v_user_count::INTEGER,
    v_total_user_profit::NUMERIC,
    v_total_company_profit::NUMERIC,
    FORMAT('✅ 日利設定完了: %s名に総額$%s配布', v_user_count, ROUND(v_total_user_profit, 2))::TEXT;

EXCEPTION WHEN OTHERS THEN
  RETURN QUERY SELECT 
    'ERROR'::TEXT,
    0::INTEGER,
    0::NUMERIC,
    0::NUMERIC,
    FORMAT('エラー: %s', SQLERRM)::TEXT;
END;
$_$;


ALTER FUNCTION "public"."simple_admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."simulate_monthly_withdrawal"() RETURNS TABLE("user_id" "text", "email" "text", "action" "text", "cum_usdt_before" numeric, "cum_usdt_after" numeric, "available_usdt_before" numeric, "available_usdt_after" numeric, "nft_to_purchase" integer, "withdrawal_amount" numeric, "notes" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
BEGIN
    -- NFT強制購入のシミュレーション
    RETURN QUERY
    SELECT 
        ac.user_id::TEXT,
        u.email::TEXT,  -- 明示的にTEXTにキャスト
        'NFT自動購入'::TEXT as action,
        ac.cum_usdt as cum_usdt_before,
        ac.cum_usdt - (FLOOR(ac.cum_usdt / 2200) * 2200) as cum_usdt_after,
        ac.available_usdt as available_usdt_before,
        ac.available_usdt + (FLOOR(ac.cum_usdt / 2200) * 1100) as available_usdt_after,
        FLOOR(ac.cum_usdt / 2200)::INTEGER as nft_to_purchase,
        0::NUMERIC as withdrawal_amount,
        ('NFT ' || FLOOR(ac.cum_usdt / 2200) || '個購入')::TEXT as notes
    FROM affiliate_cycle ac
    JOIN users u ON ac.user_id = u.user_id
    WHERE ac.cum_usdt >= 2200;
    
    -- 出金処理のシミュレーション（NFT購入後の状態を考慮）
    RETURN QUERY
    WITH after_nft AS (
        SELECT 
            ac.user_id,
            u.email,
            CASE 
                WHEN ac.cum_usdt >= 2200 THEN ac.available_usdt + (FLOOR(ac.cum_usdt / 2200) * 1100)
                ELSE ac.available_usdt
            END as new_available_usdt
        FROM affiliate_cycle ac
        JOIN users u ON ac.user_id = u.user_id
    )
    SELECT 
        an.user_id::TEXT,
        an.email::TEXT,  -- 明示的にTEXTにキャスト
        '自動出金'::TEXT as action,
        0::NUMERIC as cum_usdt_before,
        0::NUMERIC as cum_usdt_after,
        an.new_available_usdt as available_usdt_before,
        0::NUMERIC as available_usdt_after,
        0::INTEGER as nft_to_purchase,
        an.new_available_usdt as withdrawal_amount,
        ('$' || an.new_available_usdt || ' 出金申請')::TEXT as notes
    FROM after_nft an
    WHERE an.new_available_usdt >= 100
    AND NOT EXISTS (
        SELECT 1 
        FROM withdrawals w 
        WHERE w.user_id = an.user_id 
        AND w.withdrawal_type = 'monthly_auto'
        AND DATE_TRUNC('month', w.created_at AT TIME ZONE 'Asia/Tokyo') = DATE_TRUNC('month', (NOW() AT TIME ZONE 'Asia/Tokyo')::DATE)
    );
END;
$_$;


ALTER FUNCTION "public"."simulate_monthly_withdrawal"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."simulate_user_monthly_process"("p_user_id" "text") RETURNS TABLE("step" "text", "field" "text", "before_value" numeric, "after_value" numeric, "change" numeric)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_record RECORD;
    v_nft_to_buy INTEGER;
    v_cum_after NUMERIC;
    v_available_after NUMERIC;
BEGIN
    -- 現在の状態を取得
    SELECT 
        ac.*,
        u.email
    INTO v_record
    FROM affiliate_cycle ac
    JOIN users u ON ac.user_id = u.user_id
    WHERE ac.user_id = p_user_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'ユーザー % が見つかりません', p_user_id;
    END IF;
    
    -- NFT購入計算
    v_nft_to_buy := FLOOR(v_record.cum_usdt / 2200);
    v_cum_after := v_record.cum_usdt - (v_nft_to_buy * 2200);
    v_available_after := v_record.available_usdt + (v_nft_to_buy * 1100);
    
    -- 結果を返す
    RETURN QUERY
    SELECT 
        'NFT購入'::TEXT,
        'cum_usdt'::TEXT,
        v_record.cum_usdt,
        v_cum_after,
        v_cum_after - v_record.cum_usdt;
        
    RETURN QUERY
    SELECT 
        'NFT購入'::TEXT,
        'available_usdt'::TEXT,
        v_record.available_usdt,
        v_available_after,
        v_available_after - v_record.available_usdt;
        
    RETURN QUERY
    SELECT 
        'NFT購入'::TEXT,
        'total_nft_count'::TEXT,
        v_record.total_nft_count::NUMERIC,
        (v_record.total_nft_count + v_nft_to_buy)::NUMERIC,
        v_nft_to_buy::NUMERIC;
        
    RETURN QUERY
    SELECT 
        '出金'::TEXT,
        'available_usdt'::TEXT,
        v_available_after,
        CASE WHEN v_available_after >= 100 THEN 0::NUMERIC ELSE v_available_after END,
        CASE WHEN v_available_after >= 100 THEN -v_available_after ELSE 0::NUMERIC END;
END;
$$;


ALTER FUNCTION "public"."simulate_user_monthly_process"("p_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_coinw_uid_from_auth"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    sync_count INTEGER := 0;
    user_record RECORD;
BEGIN
    -- auth.usersからCoinW UIDを取得してusersテーブルを更新
    FOR user_record IN 
        SELECT 
            u.id,
            u.user_id,
            au.raw_user_meta_data->>'coinw_uid' as auth_coinw_uid
        FROM users u
        JOIN auth.users au ON au.id = u.id
        WHERE au.raw_user_meta_data->>'coinw_uid' IS NOT NULL
        AND au.raw_user_meta_data->>'coinw_uid' != ''
        AND (u.coinw_uid IS NULL OR u.coinw_uid != au.raw_user_meta_data->>'coinw_uid')
    LOOP
        UPDATE users 
        SET coinw_uid = user_record.auth_coinw_uid,
            updated_at = NOW()
        WHERE id = user_record.id;
        
        sync_count := sync_count + 1;
        RAISE LOG 'Synced CoinW UID for user %: %', user_record.user_id, user_record.auth_coinw_uid;
    END LOOP;
    
    RETURN sync_count;
END;
$$;


ALTER FUNCTION "public"."sync_coinw_uid_from_auth"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."system_health_check"() RETURNS TABLE("component" "text", "status" "text", "message" "text", "last_check" timestamp with time zone, "details" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $_$
DECLARE
    v_user_count INTEGER;
    v_active_user_count INTEGER;
    v_total_investment NUMERIC;
    v_db_size TEXT;
    v_recent_logs INTEGER;
    v_recent_errors INTEGER;
BEGIN
    -- ユーザー統計
    SELECT COUNT(*), COUNT(*) FILTER (WHERE is_active = true)
    INTO v_user_count, v_active_user_count
    FROM users;
    
    -- 投資総額
    SELECT COALESCE(SUM(amount_usd::NUMERIC), 0)
    INTO v_total_investment
    FROM purchases
    WHERE admin_approved = true;
    
    -- データベースサイズ
    SELECT pg_size_pretty(pg_database_size(current_database()))
    INTO v_db_size;
    
    -- 最近のログ数
    SELECT COUNT(*)
    INTO v_recent_logs
    FROM system_logs
    WHERE created_at > NOW() - INTERVAL '24 hours';
    
    -- 最近のエラー数
    SELECT COUNT(*)
    INTO v_recent_errors
    FROM system_logs
    WHERE created_at > NOW() - INTERVAL '24 hours'
    AND log_type IN ('error', 'critical');
    
    -- データベース接続
    RETURN QUERY
    SELECT 
        'database'::TEXT,
        'healthy'::TEXT,
        'データベース接続正常'::TEXT,
        NOW(),
        jsonb_build_object(
            'size', v_db_size,
            'version', version()
        );
    
    -- ユーザー統計
    RETURN QUERY
    SELECT 
        'users'::TEXT,
        'healthy'::TEXT,
        format('総ユーザー数: %s / アクティブ: %s', v_user_count, v_active_user_count)::TEXT,
        NOW(),
        jsonb_build_object(
            'total', v_user_count,
            'active', v_active_user_count
        );
    
    -- 投資統計
    RETURN QUERY
    SELECT 
        'investments'::TEXT,
        'healthy'::TEXT,
        format('総投資額: $%s', TO_CHAR(v_total_investment, 'FM999,999,990.00'))::TEXT,
        NOW(),
        jsonb_build_object(
            'total_amount', v_total_investment
        );
    
    -- ログシステム
    RETURN QUERY
    SELECT 
        'logging'::TEXT,
        CASE 
            WHEN v_recent_errors > 10 THEN 'warning'
            ELSE 'healthy'
        END::TEXT,
        format('24時間以内: %sログ / %sエラー', v_recent_logs, v_recent_errors)::TEXT,
        NOW(),
        jsonb_build_object(
            'recent_logs', v_recent_logs,
            'recent_errors', v_recent_errors
        );
    
    -- NFTサイクル
    RETURN QUERY
    SELECT 
        'nft_cycles'::TEXT,
        'healthy'::TEXT,
        'NFTサイクル処理正常'::TEXT,
        NOW(),
        (SELECT jsonb_build_object(
            'active_cycles', COUNT(*),
            'total_nft', SUM(total_nft_count)
        ) FROM affiliate_cycle WHERE total_nft_count > 0);
    
END;
$_$;


ALTER FUNCTION "public"."system_health_check"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."test_monthly_auto_withdrawal"("p_force" boolean DEFAULT false) RETURNS TABLE("user_id" "text", "email" "text", "available_usdt" numeric, "withdrawal_address" "text", "coinw_uid" "text", "would_process" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ac.user_id,
        u.email,
        ac.available_usdt,
        uws.withdrawal_address,
        uws.coinw_uid,
        (ac.available_usdt >= 100)::BOOLEAN as would_process
    FROM affiliate_cycle ac
    JOIN users u ON ac.user_id = u.user_id
    LEFT JOIN user_withdrawal_settings uws ON ac.user_id = uws.user_id
    WHERE ac.available_usdt > 0
    ORDER BY ac.available_usdt DESC;
END;
$$;


ALTER FUNCTION "public"."test_monthly_auto_withdrawal"("p_force" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."test_update_nft_count"("p_user_id" "text", "p_manual_count" integer, "p_auto_count" integer) RETURNS TABLE("success" boolean, "message" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- affiliate_cycleのNFT数を更新
    UPDATE affiliate_cycle
    SET 
        manual_nft_count = p_manual_count,
        auto_nft_count = p_auto_count,
        total_nft_count = p_manual_count + p_auto_count,
        last_updated = NOW()
    WHERE user_id = p_user_id;
    
    IF FOUND THEN
        RETURN QUERY
        SELECT 
            TRUE,
            format('ユーザー %s のNFT数を更新しました: 手動=%s, 自動=%s, 合計=%s', 
                   p_user_id, p_manual_count, p_auto_count, p_manual_count + p_auto_count)::TEXT;
    ELSE
        RETURN QUERY
        SELECT 
            FALSE,
            format('ユーザー %s が見つかりません', p_user_id)::TEXT;
    END IF;
END;
$$;


ALTER FUNCTION "public"."test_update_nft_count"("p_user_id" "text", "p_manual_count" integer, "p_auto_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."text_to_html"("p_text" "text") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
    v_html TEXT;
BEGIN
    -- すでにHTMLタグが含まれている場合はそのまま返す
    IF p_text ~ '<[a-zA-Z][\s\S]*>' THEN
        RETURN p_text;
    END IF;

    v_html := p_text;

    -- ⭐ 先にURLをリンク化（エスケープ前に実行）
    -- https:// または http:// で始まるURL
    v_html := REGEXP_REPLACE(
        v_html,
        '(https?://[^\s]+)',
        '<<<LINK:\1>>>',
        'g'
    );

    -- www. で始まるURL
    v_html := REGEXP_REPLACE(
        v_html,
        '([^/])(www\.[^\s]+)',
        '\1<<<LINK:http://\2>>>',
        'g'
    );

    -- エスケープ処理（XSS対策）
    v_html := REPLACE(v_html, '&', '&amp;');
    v_html := REPLACE(v_html, '<', '&lt;');
    v_html := REPLACE(v_html, '>', '&gt;');
    v_html := REPLACE(v_html, '"', '&quot;');
    v_html := REPLACE(v_html, '''', '&#039;');

    -- ⭐ プレースホルダーを実際のリンクに戻す
    v_html := REGEXP_REPLACE(
        v_html,
        '&lt;&lt;&lt;LINK:([^&]+)&gt;&gt;&gt;',
        '<a href="\1" style="color: #3b82f6; text-decoration: underline;">\1</a>',
        'g'
    );

    -- 改行を<br>に変換
    v_html := REPLACE(v_html, E'\n', '<br>');

    -- HTMLテンプレートでラップ
    RETURN '<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .content {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
        }
        a {
            color: #3b82f6;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="content">
        ' || v_html || '
    </div>
    <div style="text-align: center; margin-top: 30px; color: #666; font-size: 12px;">
        <p>このメールは HASHPILOT システムから送信されています。</p>
        <p>© 2025 HASHPILOT. All rights reserved.</p>
    </div>
</body>
</html>';
END;
$$;


ALTER FUNCTION "public"."text_to_html"("p_text" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_nft_distribution_status"("p_user_id" "text", "p_is_distributed" boolean, "p_admin_user_id" "text", "p_notes" "text" DEFAULT NULL::"text") RETURNS TABLE("success" boolean, "message" "text", "user_id" "text", "previous_status" boolean, "new_status" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_exists BOOLEAN;
    v_previous_status BOOLEAN;
    v_admin_email TEXT;
BEGIN
    -- ユーザーの存在確認
    SELECT EXISTS(
        SELECT 1 FROM users WHERE users.user_id = p_user_id
    ), nft_distributed
    INTO v_user_exists, v_previous_status
    FROM users 
    WHERE users.user_id = p_user_id;
    
    IF NOT v_user_exists THEN
        RETURN QUERY SELECT 
            FALSE,
            'ユーザーが見つかりません',
            p_user_id,
            FALSE,
            FALSE;
        RETURN;
    END IF;
    
    -- 管理者の確認
    SELECT email INTO v_admin_email
    FROM users 
    WHERE users.user_id = p_admin_user_id;
    
    -- NFT配布状況を更新
    UPDATE users SET
        nft_distributed = p_is_distributed,
        nft_distributed_at = CASE 
            WHEN p_is_distributed THEN NOW()
            ELSE NULL
        END,
        nft_distributed_by = CASE 
            WHEN p_is_distributed THEN COALESCE(v_admin_email, p_admin_user_id)
            ELSE NULL
        END,
        nft_distribution_notes = CASE 
            WHEN p_is_distributed THEN p_notes
            ELSE NULL
        END,
        updated_at = NOW()
    WHERE users.user_id = p_user_id;
    
    -- システムログに記録
    INSERT INTO system_logs (
        log_type,
        operation,
        user_id,
        message,
        details,
        created_at
    ) VALUES (
        'INFO',
        'nft_distribution_update',
        p_user_id,
        CASE 
            WHEN p_is_distributed THEN 'NFT配布完了に設定されました'
            ELSE 'NFT配布状況が未配布に変更されました'
        END,
        jsonb_build_object(
            'admin_user_id', p_admin_user_id,
            'previous_status', v_previous_status,
            'new_status', p_is_distributed,
            'notes', p_notes
        ),
        NOW()
    );
    
    RETURN QUERY SELECT 
        TRUE,
        CASE 
            WHEN p_is_distributed THEN 'NFT配布完了に設定しました'
            ELSE 'NFT配布状況を未配布に変更しました'
        END,
        p_user_id,
        v_previous_status,
        p_is_distributed;
END;
$$;


ALTER FUNCTION "public"."update_nft_distribution_status"("p_user_id" "text", "p_is_distributed" boolean, "p_admin_user_id" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_active_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- nft_masterのbuyback_dateが更新されたとき
    -- そのユーザーの保有NFT数をチェック
    UPDATE users
    SET is_active_investor = (
        SELECT COUNT(*) > 0
        FROM nft_master
        WHERE user_id = NEW.user_id
          AND buyback_date IS NULL
    )
    WHERE user_id = NEW.user_id;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_user_active_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_addresses"("target_user_id" "text", "new_reward_address" "text" DEFAULT NULL::"text", "new_nft_address" "text" DEFAULT NULL::"text", "admin_email" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  result JSON;
BEGIN
  -- 管理者権限チェック
  IF admin_email IS NOT NULL THEN
    IF NOT EXISTS (SELECT 1 FROM admins WHERE email = admin_email AND is_active = true) THEN
      RETURN json_build_object('success', false, 'message', '管理者権限がありません');
    END IF;
  END IF;

  -- ユーザーのアドレスを更新
  UPDATE users 
  SET 
    reward_address_bep20 = COALESCE(new_reward_address, reward_address_bep20),
    nft_address = COALESCE(new_nft_address, nft_address),
    updated_at = NOW()
  WHERE user_id = target_user_id;

  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'message', 'ユーザーが見つかりません');
  END IF;

  RETURN json_build_object('success', true, 'message', 'アドレスを更新しました');
END;
$$;


ALTER FUNCTION "public"."update_user_addresses"("target_user_id" "text", "new_reward_address" "text", "new_nft_address" "text", "admin_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_purchase_total"("target_user_id" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    total_amount NUMERIC;
BEGIN
    -- 承認済み購入の合計を計算
    SELECT COALESCE(SUM(amount_usd), 0) INTO total_amount
    FROM purchases 
    WHERE user_id = target_user_id AND admin_approved = TRUE;
    
    -- usersテーブルを更新
    UPDATE users 
    SET total_purchases = total_amount
    WHERE user_id = target_user_id;
    
    RAISE NOTICE 'Updated user % total purchases to %', target_user_id, total_amount;
END;
$$;


ALTER FUNCTION "public"."update_user_purchase_total"("target_user_id" "text") OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."nft_master" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text" NOT NULL,
    "nft_sequence" integer NOT NULL,
    "nft_type" "text" NOT NULL,
    "nft_value" numeric(10,2) NOT NULL,
    "acquired_date" "date" NOT NULL,
    "buyback_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "nft_master_nft_type_check" CHECK (("nft_type" = ANY (ARRAY['manual'::"text", 'auto'::"text"])))
);


ALTER TABLE "public"."nft_master" OWNER TO "postgres";


COMMENT ON TABLE "public"."nft_master" IS 'NFTマスターテーブル - 各NFTの基本情報を管理';



CREATE TABLE IF NOT EXISTS "public"."purchases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" character varying(6),
    "nft_quantity" integer NOT NULL,
    "amount_usd" numeric(10,2) NOT NULL,
    "usdt_address_bep20" character varying(255),
    "usdt_address_trc20" character varying(255),
    "payment_status" character varying(20) DEFAULT 'pending'::character varying,
    "nft_sent" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "confirmed_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "admin_approved" boolean DEFAULT false,
    "admin_approved_at" timestamp with time zone,
    "admin_approved_by" "text",
    "payment_proof_url" "text",
    "user_notes" "text",
    "admin_notes" "text",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_auto_purchase" boolean DEFAULT false,
    "cycle_number_at_purchase" integer
);


ALTER TABLE "public"."purchases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" NOT NULL,
    "user_id" character varying(6) NOT NULL,
    "email" character varying(255) NOT NULL,
    "full_name" character varying(255),
    "referrer_user_id" character varying(6),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT false,
    "total_purchases" numeric(10,2) DEFAULT 0,
    "total_referral_earnings" numeric(10,2) DEFAULT 0,
    "has_approved_nft" boolean DEFAULT false,
    "first_nft_approved_at" timestamp with time zone,
    "coinw_uid" "text",
    "reward_address_bep20" "text",
    "nft_address" "text",
    "nft_sent" boolean DEFAULT false,
    "nft_sent_at" timestamp with time zone,
    "nft_sent_by" "text",
    "nft_receive_address" "text",
    "coinw_uid_for_withdrawal" "text",
    "nft_distributed" boolean DEFAULT false,
    "nft_distributed_at" timestamp with time zone,
    "nft_distributed_by" "text",
    "nft_distribution_notes" "text",
    "is_pegasus_exchange" boolean DEFAULT false,
    "pegasus_exchange_date" "date",
    "pegasus_withdrawal_unlock_date" "date",
    "is_active_investor" boolean DEFAULT false,
    "operation_start_date" "date",
    "is_operation_only" boolean DEFAULT false,
    "email_blacklisted" boolean DEFAULT false
);


ALTER TABLE "public"."users" OWNER TO "postgres";


COMMENT ON COLUMN "public"."users"."reward_address_bep20" IS '報酬受け取りアドレス（USDT BEP20）';



COMMENT ON COLUMN "public"."users"."nft_receive_address" IS 'NFT受取アドレス';



COMMENT ON COLUMN "public"."users"."is_pegasus_exchange" IS 'ペガサスNFT交換フラグ（管理者のみ表示）';



COMMENT ON COLUMN "public"."users"."pegasus_exchange_date" IS 'ペガサスNFT交換日';



COMMENT ON COLUMN "public"."users"."pegasus_withdrawal_unlock_date" IS '出金解禁日（この日以降出金可能）';



COMMENT ON COLUMN "public"."users"."is_active_investor" IS 'NFT保有中=TRUE、全売却=FALSE';



COMMENT ON COLUMN "public"."users"."operation_start_date" IS '運用開始日（新ルール: 5日までに購入→当月15日、20日までに購入→翌月1日）';



COMMENT ON COLUMN "public"."users"."is_operation_only" IS '運用専用ユーザーフラグ（trueの場合、紹介UIを非表示）';



COMMENT ON COLUMN "public"."users"."email_blacklisted" IS 'メール送信除外フラグ（trueの場合、一斉送信の対象外）';



CREATE OR REPLACE VIEW "public"."admin_auto_nft_grants_view" AS
 SELECT "p"."id",
    "p"."user_id",
    "u"."email",
    "u"."full_name",
    "p"."nft_quantity",
    "p"."amount_usd",
    "p"."admin_approved_at" AS "granted_at",
    "p"."created_at",
    "u"."has_approved_nft",
    ( SELECT "count"(*) AS "count"
           FROM "public"."nft_master" "nm"
          WHERE (("nm"."user_id" = ("p"."user_id")::"text") AND ("nm"."nft_type" = 'auto'::"text") AND ("nm"."buyback_date" IS NULL))) AS "current_auto_nft_count",
    ( SELECT "json_agg"("json_build_object"('nft_sequence', "nm"."nft_sequence", 'nft_value', "nm"."nft_value", 'acquired_date', "nm"."acquired_date") ORDER BY "nm"."nft_sequence" DESC) AS "json_agg"
           FROM "public"."nft_master" "nm"
          WHERE (("nm"."user_id" = ("p"."user_id")::"text") AND ("nm"."nft_type" = 'auto'::"text") AND ("nm"."buyback_date" IS NULL))) AS "nft_details"
   FROM ("public"."purchases" "p"
     JOIN "public"."users" "u" ON ((("p"."user_id")::"text" = ("u"."user_id")::"text")))
  WHERE ("p"."is_auto_purchase" = true)
  ORDER BY "p"."created_at" DESC;


ALTER VIEW "public"."admin_auto_nft_grants_view" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."admin_purchases_view" AS
 SELECT "p"."id",
    "p"."user_id",
    "u"."email",
    "u"."full_name",
    "u"."coinw_uid",
    "u"."nft_receive_address",
    "u"."referrer_user_id",
    "ref"."email" AS "referrer_email",
    "ref"."full_name" AS "referrer_full_name",
    "p"."nft_quantity",
    "p"."amount_usd",
    "p"."payment_status",
    "p"."admin_approved",
    "p"."admin_approved_at",
    "p"."admin_approved_by",
    "p"."payment_proof_url",
    "p"."user_notes",
    "p"."admin_notes",
    "p"."created_at",
    "u"."has_approved_nft",
    "p"."is_auto_purchase"
   FROM (("public"."purchases" "p"
     JOIN "public"."users" "u" ON ((("p"."user_id")::"text" = ("u"."user_id")::"text")))
     LEFT JOIN "public"."users" "ref" ON ((("u"."referrer_user_id")::"text" = ("ref"."user_id")::"text")))
  WHERE (COALESCE("p"."is_auto_purchase", false) = false)
  ORDER BY "p"."created_at" DESC;


ALTER VIEW "public"."admin_purchases_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admins" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text",
    "email" "text" NOT NULL,
    "role" "text" DEFAULT 'admin'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."admins" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."affiliate_cycle" (
    "id" integer NOT NULL,
    "user_id" "text" NOT NULL,
    "cycle_number" integer DEFAULT 1 NOT NULL,
    "phase" character varying(10) DEFAULT 'USDT'::character varying NOT NULL,
    "cum_usdt" numeric(10,2) DEFAULT 0.00 NOT NULL,
    "available_usdt" numeric(10,2) DEFAULT 0.00 NOT NULL,
    "total_nft_count" integer DEFAULT 0 NOT NULL,
    "auto_nft_count" integer DEFAULT 0 NOT NULL,
    "manual_nft_count" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "cycle_start_date" timestamp with time zone,
    "last_updated" timestamp with time zone DEFAULT "now"(),
    "next_action" "text" DEFAULT 'usdt'::"text",
    CONSTRAINT "affiliate_cycle_phase_check" CHECK ((("phase")::"text" = ANY ((ARRAY['USDT'::character varying, 'HOLD'::character varying])::"text"[])))
);


ALTER TABLE "public"."affiliate_cycle" OWNER TO "postgres";


COMMENT ON TABLE "public"."affiliate_cycle" IS 'ユーザーサイクル管理 - USDT/HOLDフェーズ、NFT数管理';



CREATE SEQUENCE IF NOT EXISTS "public"."affiliate_cycle_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."affiliate_cycle_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."affiliate_cycle_id_seq" OWNED BY "public"."affiliate_cycle"."id";



CREATE TABLE IF NOT EXISTS "public"."affiliate_reward" (
    "id" integer NOT NULL,
    "user_id" "text" NOT NULL,
    "referral_user_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "level" integer NOT NULL,
    "reward_rate" numeric(4,3) NOT NULL,
    "base_profit" numeric(10,2) NOT NULL,
    "reward_amount" numeric(10,2) NOT NULL,
    "phase" character varying(10) NOT NULL,
    "is_paid" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "affiliate_reward_level_check" CHECK (("level" = ANY (ARRAY[1, 2, 3]))),
    CONSTRAINT "affiliate_reward_phase_check" CHECK ((("phase")::"text" = ANY ((ARRAY['USDT'::character varying, 'HOLD'::character varying])::"text"[])))
);


ALTER TABLE "public"."affiliate_reward" OWNER TO "postgres";


COMMENT ON TABLE "public"."affiliate_reward" IS '紹介報酬記録';



CREATE SEQUENCE IF NOT EXISTS "public"."affiliate_reward_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."affiliate_reward_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."affiliate_reward_id_seq" OWNED BY "public"."affiliate_reward"."id";



CREATE TABLE IF NOT EXISTS "public"."backup_auth_users_metadata_20250706" (
    "id" "uuid",
    "email" character varying(255),
    "raw_user_meta_data" "jsonb",
    "created_at" timestamp with time zone,
    "email_confirmed_at" timestamp with time zone,
    "last_sign_in_at" timestamp with time zone
);


ALTER TABLE "public"."backup_auth_users_metadata_20250706" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."backup_problem_users_20250706" (
    "id" "uuid",
    "user_id" character varying(6),
    "email" character varying(255),
    "referrer_user_id" character varying(6),
    "coinw_uid" character varying(255),
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "raw_user_meta_data" "jsonb",
    "issue_type" "text"
);


ALTER TABLE "public"."backup_problem_users_20250706" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."backup_purchases_20250706" (
    "id" "uuid",
    "user_id" character varying(6),
    "nft_quantity" integer,
    "amount_usd" numeric(10,2),
    "usdt_address_bep20" character varying(255),
    "usdt_address_trc20" character varying(255),
    "payment_status" character varying(20),
    "nft_sent" boolean,
    "created_at" timestamp with time zone,
    "confirmed_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "admin_approved" boolean,
    "admin_approved_at" timestamp with time zone,
    "admin_approved_by" "text",
    "payment_proof_url" "text",
    "user_notes" "text",
    "admin_notes" "text"
);


ALTER TABLE "public"."backup_purchases_20250706" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."backup_users_20250706" (
    "id" "uuid",
    "user_id" character varying(6),
    "email" character varying(255),
    "full_name" character varying(255),
    "referrer_user_id" character varying(6),
    "coinw_uid" character varying(255),
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "is_active" boolean,
    "has_approved_nft" boolean,
    "total_purchases" numeric(10,2),
    "total_referral_earnings" numeric(10,2)
);


ALTER TABLE "public"."backup_users_20250706" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."buyback_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text" NOT NULL,
    "email" "text",
    "request_date" timestamp with time zone DEFAULT "now"(),
    "manual_nft_count" integer DEFAULT 0 NOT NULL,
    "auto_nft_count" integer DEFAULT 0 NOT NULL,
    "total_nft_count" integer DEFAULT 0 NOT NULL,
    "manual_buyback_amount" numeric(10,2) DEFAULT 0 NOT NULL,
    "auto_buyback_amount" numeric(10,2) DEFAULT 0 NOT NULL,
    "total_buyback_amount" numeric(10,2) DEFAULT 0 NOT NULL,
    "wallet_address" "text",
    "wallet_type" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "processed_by" "text",
    "processed_at" timestamp with time zone,
    "transaction_hash" "text",
    "admin_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "buyback_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'processing'::"text", 'completed'::"text", 'cancelled'::"text", 'rejected'::"text"]))),
    CONSTRAINT "buyback_requests_wallet_type_check" CHECK (("wallet_type" = ANY (ARRAY['USDT-BEP20'::"text", 'CoinW'::"text"])))
);


ALTER TABLE "public"."buyback_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_bonus_from_dormant" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "date" "date" NOT NULL,
    "dormant_user_id" "text" NOT NULL,
    "dormant_user_email" "text",
    "child_user_id" "text" NOT NULL,
    "referral_level" integer NOT NULL,
    "original_amount" numeric(10,3) NOT NULL,
    "company_user_id" "text" DEFAULT '7A9637'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "company_bonus_from_dormant_referral_level_check" CHECK (("referral_level" = ANY (ARRAY[1, 2, 3])))
);


ALTER TABLE "public"."company_bonus_from_dormant" OWNER TO "postgres";


COMMENT ON TABLE "public"."company_bonus_from_dormant" IS '休眠ユーザーの紹介報酬を会社が受け取った記録';



CREATE TABLE IF NOT EXISTS "public"."user_referral_profit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "referral_level" integer NOT NULL,
    "child_user_id" "text" NOT NULL,
    "profit_amount" numeric(10,3) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_referral_profit_referral_level_check" CHECK (("referral_level" = ANY (ARRAY[1, 2, 3])))
);


ALTER TABLE "public"."user_referral_profit" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_referral_profit" IS 'ユーザーが受け取った紹介報酬の記録';



COMMENT ON COLUMN "public"."user_referral_profit"."user_id" IS '報酬を受け取るユーザーID';



COMMENT ON COLUMN "public"."user_referral_profit"."referral_level" IS '紹介レベル (1=直接, 2=間接1, 3=間接2)';



COMMENT ON COLUMN "public"."user_referral_profit"."child_user_id" IS '報酬発生元（下位ユーザー）のID';



COMMENT ON COLUMN "public"."user_referral_profit"."profit_amount" IS '報酬額（ドル）';



CREATE OR REPLACE VIEW "public"."company_account_referral_summary" AS
 SELECT "urp"."date",
    "sum"("urp"."profit_amount") AS "total_referral_profit",
    "sum"(
        CASE
            WHEN ("urp"."referral_level" = 1) THEN "urp"."profit_amount"
            ELSE (0)::numeric
        END) AS "level1_profit",
    "sum"(
        CASE
            WHEN ("urp"."referral_level" = 2) THEN "urp"."profit_amount"
            ELSE (0)::numeric
        END) AS "level2_profit",
    "sum"(
        CASE
            WHEN ("urp"."referral_level" = 3) THEN "urp"."profit_amount"
            ELSE (0)::numeric
        END) AS "level3_profit",
    "count"(DISTINCT "urp"."child_user_id") AS "unique_children",
    COALESCE("cb"."dormant_bonus", (0)::numeric) AS "bonus_from_dormant",
    ("sum"("urp"."profit_amount") - COALESCE("cb"."dormant_bonus", (0)::numeric)) AS "normal_referral_profit"
   FROM ("public"."user_referral_profit" "urp"
     LEFT JOIN ( SELECT "company_bonus_from_dormant"."date",
            "sum"("company_bonus_from_dormant"."original_amount") AS "dormant_bonus"
           FROM "public"."company_bonus_from_dormant"
          GROUP BY "company_bonus_from_dormant"."date") "cb" ON (("urp"."date" = "cb"."date")))
  WHERE ("urp"."user_id" = '7A9637'::"text")
  GROUP BY "urp"."date", "cb"."dormant_bonus"
  ORDER BY "urp"."date" DESC;


ALTER VIEW "public"."company_account_referral_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."company_account_referral_summary" IS '7A9637の紹介報酬サマリー（通常報酬と休眠ボーナスを分離）';



CREATE OR REPLACE VIEW "public"."company_bonus_summary" AS
 SELECT "date",
    "count"(*) AS "bonus_count",
    "sum"("original_amount") AS "total_bonus",
    "count"(DISTINCT "dormant_user_id") AS "dormant_users_count",
    "count"(DISTINCT "child_user_id") AS "active_children_count"
   FROM "public"."company_bonus_from_dormant"
  GROUP BY "date"
  ORDER BY "date" DESC;


ALTER VIEW "public"."company_bonus_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."company_bonus_summary" IS '会社ボーナスの日次サマリー';



CREATE TABLE IF NOT EXISTS "public"."company_daily_profit" (
    "id" integer NOT NULL,
    "date" "date" NOT NULL,
    "total_user_profit" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_company_profit" numeric(12,2) DEFAULT 0 NOT NULL,
    "margin_rate" numeric(3,2) NOT NULL,
    "total_base_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "user_count" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."company_daily_profit" OWNER TO "postgres";


COMMENT ON TABLE "public"."company_daily_profit" IS '会社日利記録';



CREATE SEQUENCE IF NOT EXISTS "public"."company_daily_profit_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."company_daily_profit_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."company_daily_profit_id_seq" OWNED BY "public"."company_daily_profit"."id";



CREATE TABLE IF NOT EXISTS "public"."daily_yield_log" (
    "id" integer NOT NULL,
    "date" "date" NOT NULL,
    "yield_rate" numeric(10,6) NOT NULL,
    "margin_rate" numeric(10,4) NOT NULL,
    "user_rate" numeric(10,6) NOT NULL,
    "is_month_end" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid"
);


ALTER TABLE "public"."daily_yield_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."daily_yield_log" IS '日利率ログ - 管理者が毎日入力';



CREATE SEQUENCE IF NOT EXISTS "public"."daily_yield_log_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."daily_yield_log_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."daily_yield_log_id_seq" OWNED BY "public"."daily_yield_log"."id";



CREATE OR REPLACE VIEW "public"."dormant_users_list" AS
 SELECT "u"."user_id",
    "u"."email",
    "u"."full_name",
    "ac"."total_nft_count" AS "current_nft_count",
    "ac"."cycle_number",
    ( SELECT "count"(*) AS "count"
           FROM "public"."users" "child"
          WHERE ((("child"."referrer_user_id")::"text" = ("u"."user_id")::"text") AND ("child"."is_active_investor" = true))) AS "active_children_count",
    ( SELECT "sum"("company_bonus_from_dormant"."original_amount") AS "sum"
           FROM "public"."company_bonus_from_dormant"
          WHERE (("company_bonus_from_dormant"."dormant_user_id" = ("u"."user_id")::"text") AND ("company_bonus_from_dormant"."date" >= (CURRENT_DATE - '30 days'::interval)))) AS "company_bonus_last_30_days"
   FROM ("public"."users" "u"
     LEFT JOIN "public"."affiliate_cycle" "ac" ON ((("u"."user_id")::"text" = "ac"."user_id")))
  WHERE (("u"."is_active_investor" = false) AND (("u"."user_id")::"text" <> '7A9637'::"text"))
  ORDER BY ( SELECT "sum"("company_bonus_from_dormant"."original_amount") AS "sum"
           FROM "public"."company_bonus_from_dormant"
          WHERE (("company_bonus_from_dormant"."dormant_user_id" = ("u"."user_id")::"text") AND ("company_bonus_from_dormant"."date" >= (CURRENT_DATE - '30 days'::interval)))) DESC NULLS LAST;


ALTER VIEW "public"."dormant_users_list" OWNER TO "postgres";


COMMENT ON VIEW "public"."dormant_users_list" IS '休眠ユーザー一覧と会社ボーナス貢献度';



CREATE TABLE IF NOT EXISTS "public"."email_recipients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email_id" "uuid" NOT NULL,
    "user_id" "text" NOT NULL,
    "to_email" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "sent_at" timestamp with time zone,
    "read_at" timestamp with time zone,
    "error_message" "text",
    "resend_email_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "email_recipients_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'failed'::"text", 'read'::"text"]))),
    CONSTRAINT "valid_status" CHECK (("status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'failed'::"text", 'read'::"text"])))
);


ALTER TABLE "public"."email_recipients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."email_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "subject" "text" NOT NULL,
    "body" "text" NOT NULL,
    "description" "text",
    "created_by" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."email_templates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."monthly_reward_tasks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" character varying(6) NOT NULL,
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "is_completed" boolean DEFAULT false,
    "completed_at" timestamp without time zone,
    "questions_answered" integer DEFAULT 0,
    "answers" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."monthly_reward_tasks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."monthly_withdrawals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text" NOT NULL,
    "email" "text" NOT NULL,
    "withdrawal_month" "date" NOT NULL,
    "level1_reward" numeric(10,3) DEFAULT 0,
    "level2_reward" numeric(10,3) DEFAULT 0,
    "level3_reward" numeric(10,3) DEFAULT 0,
    "level4_plus_reward" numeric(10,3) DEFAULT 0,
    "daily_profit" numeric(10,3) DEFAULT 0,
    "total_amount" numeric(10,3) NOT NULL,
    "withdrawal_address" "text",
    "withdrawal_method" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "processed_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "notes" "text",
    "task_completed" boolean DEFAULT false,
    "task_completed_at" timestamp without time zone
);


ALTER TABLE "public"."monthly_withdrawals" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."nft_count_audit" AS
 SELECT "u"."user_id",
    "u"."email",
    "u"."total_purchases" AS "recorded_amount",
    "ac"."total_nft_count" AS "recorded_nft",
    COALESCE("p"."actual_amount", (0)::numeric) AS "actual_amount",
    COALESCE("p"."actual_nft", (0)::bigint) AS "actual_nft",
        CASE
            WHEN (("u"."total_purchases" = COALESCE("p"."actual_amount", (0)::numeric)) AND ("ac"."total_nft_count" = COALESCE("p"."actual_nft", (0)::bigint))) THEN 'OK'::"text"
            ELSE 'DISCREPANCY'::"text"
        END AS "status",
    ("u"."total_purchases" - COALESCE("p"."actual_amount", (0)::numeric)) AS "amount_diff",
    ("ac"."total_nft_count" - COALESCE("p"."actual_nft", (0)::bigint)) AS "nft_diff"
   FROM (("public"."users" "u"
     LEFT JOIN "public"."affiliate_cycle" "ac" ON ((("u"."user_id")::"text" = "ac"."user_id")))
     LEFT JOIN ( SELECT "purchases"."user_id",
            "sum"("purchases"."amount_usd") AS "actual_amount",
            "sum"("purchases"."nft_quantity") AS "actual_nft"
           FROM "public"."purchases"
          WHERE ("purchases"."admin_approved" = true)
          GROUP BY "purchases"."user_id") "p" ON ((("u"."user_id")::"text" = ("p"."user_id")::"text")))
  WHERE ("u"."has_approved_nft" = true);


ALTER VIEW "public"."nft_count_audit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."nft_daily_profit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "nft_id" "uuid" NOT NULL,
    "user_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "daily_profit" numeric(10,3) NOT NULL,
    "yield_rate" numeric(10,6),
    "user_rate" numeric(10,6),
    "base_amount" numeric(10,2),
    "phase" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."nft_daily_profit" OWNER TO "postgres";


COMMENT ON TABLE "public"."nft_daily_profit" IS 'NFT日次利益テーブル - NFTごとの個人収益を記録';



CREATE TABLE IF NOT EXISTS "public"."nft_holdings" (
    "id" integer NOT NULL,
    "user_id" "text" NOT NULL,
    "nft_type" character varying(20) NOT NULL,
    "purchase_amount" numeric(10,2) DEFAULT 1100.00 NOT NULL,
    "purchase_date" timestamp with time zone DEFAULT "now"(),
    "cycle_number" integer DEFAULT 1 NOT NULL,
    "transaction_id" character varying(100),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "original_purchase_id" "uuid",
    CONSTRAINT "nft_holdings_nft_type_check" CHECK ((("nft_type")::"text" = ANY ((ARRAY['manual_purchase'::character varying, 'auto_buy'::character varying])::"text"[])))
);


ALTER TABLE "public"."nft_holdings" OWNER TO "postgres";


COMMENT ON TABLE "public"."nft_holdings" IS 'NFT保有履歴 - 手動購入/自動購入の区別';



CREATE SEQUENCE IF NOT EXISTS "public"."nft_holdings_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."nft_holdings_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."nft_holdings_id_seq" OWNED BY "public"."nft_holdings"."id";



CREATE TABLE IF NOT EXISTS "public"."nft_referral_profit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "nft_id" "uuid" NOT NULL,
    "user_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "referral_profit" numeric(10,3) NOT NULL,
    "level1_profit" numeric(10,3) DEFAULT 0,
    "level2_profit" numeric(10,3) DEFAULT 0,
    "level3_profit" numeric(10,3) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."nft_referral_profit" OWNER TO "postgres";


COMMENT ON TABLE "public"."nft_referral_profit" IS 'NFT紹介報酬テーブル - NFTごとの紹介報酬を記録';



CREATE OR REPLACE VIEW "public"."nft_total_profit" AS
 SELECT "nm"."id" AS "nft_id",
    "nm"."user_id",
    "nm"."nft_sequence",
    "nm"."nft_type",
    "nm"."nft_value",
    "nm"."acquired_date",
    "nm"."buyback_date",
    COALESCE("sum"("ndp"."daily_profit"), (0)::numeric) AS "total_personal_profit",
    COALESCE("sum"("nrp"."referral_profit"), (0)::numeric) AS "total_referral_profit",
    COALESCE("sum"("ndp"."daily_profit"), (0)::numeric) AS "total_profit_for_buyback"
   FROM (("public"."nft_master" "nm"
     LEFT JOIN "public"."nft_daily_profit" "ndp" ON (("nm"."id" = "ndp"."nft_id")))
     LEFT JOIN "public"."nft_referral_profit" "nrp" ON (("nm"."id" = "nrp"."nft_id")))
  GROUP BY "nm"."id", "nm"."user_id", "nm"."nft_sequence", "nm"."nft_type", "nm"."nft_value", "nm"."acquired_date", "nm"."buyback_date";


ALTER VIEW "public"."nft_total_profit" OWNER TO "postgres";


COMMENT ON VIEW "public"."nft_total_profit" IS 'NFTごとの累計利益ビュー';



CREATE TABLE IF NOT EXISTS "public"."payments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "purchase_id" "uuid",
    "transaction_hash" character varying(255),
    "network" character varying(10),
    "amount" numeric(10,2),
    "confirmed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."payments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pre_restore_users_20250706" (
    "id" "uuid",
    "user_id" character varying(6),
    "email" character varying(255),
    "full_name" character varying(255),
    "referrer_user_id" character varying(6),
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "is_active" boolean,
    "total_purchases" numeric(10,2),
    "total_referral_earnings" numeric(10,2),
    "has_approved_nft" boolean,
    "first_nft_approved_at" timestamp with time zone,
    "coinw_uid" character varying(255)
);


ALTER TABLE "public"."pre_restore_users_20250706" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."purchase_admin_view" AS
 SELECT "p"."id",
    "p"."user_id",
    "u"."email",
    "u"."full_name",
    "p"."nft_quantity",
    "p"."amount_usd",
    "p"."payment_status",
    "p"."admin_approved",
    "p"."admin_approved_at",
    "p"."admin_approved_by",
    "p"."payment_proof_url",
    "p"."user_notes",
    "p"."admin_notes",
    "p"."created_at",
    "p"."confirmed_at",
    "p"."completed_at",
    "u"."has_approved_nft"
   FROM ("public"."purchases" "p"
     JOIN "public"."users" "u" ON ((("p"."user_id")::"text" = ("u"."user_id")::"text")))
  ORDER BY "p"."created_at" DESC;


ALTER VIEW "public"."purchase_admin_view" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."purchase_integrity_check" AS
 WITH "actual_purchases" AS (
         SELECT "purchases"."user_id",
            "count"(*) AS "purchase_count",
            "sum"(
                CASE
                    WHEN "purchases"."admin_approved" THEN "purchases"."amount_usd"
                    ELSE (0)::numeric
                END) AS "approved_total",
            "sum"("purchases"."amount_usd") AS "all_purchases_total",
            "count"(
                CASE
                    WHEN "purchases"."admin_approved" THEN 1
                    ELSE NULL::integer
                END) AS "approved_count"
           FROM "public"."purchases"
          GROUP BY "purchases"."user_id"
        ), "user_comparison" AS (
         SELECT "u"."user_id",
            "u"."email",
            "u"."total_purchases" AS "recorded_amount",
            COALESCE("ap"."approved_total", (0)::numeric) AS "actual_approved_amount",
            COALESCE("ap"."all_purchases_total", (0)::numeric) AS "all_purchases_amount",
            COALESCE("ap"."purchase_count", (0)::bigint) AS "purchase_count",
            COALESCE("ap"."approved_count", (0)::bigint) AS "approved_count",
            ("u"."total_purchases" - COALESCE("ap"."approved_total", (0)::numeric)) AS "difference"
           FROM ("public"."users" "u"
             LEFT JOIN "actual_purchases" "ap" ON ((("u"."user_id")::"text" = ("ap"."user_id")::"text")))
          WHERE (("u"."total_purchases" > (0)::numeric) OR ("ap"."approved_total" > (0)::numeric))
        )
 SELECT "user_id",
    "email",
    "recorded_amount",
    "actual_approved_amount",
    "all_purchases_amount",
    "purchase_count",
    "approved_count",
    "difference",
        CASE
            WHEN ("abs"("difference") < 0.01) THEN 'OK'::"text"
            WHEN ("difference" > (0)::numeric) THEN 'OVER_RECORDED'::"text"
            WHEN ("difference" < (0)::numeric) THEN 'UNDER_RECORDED'::"text"
            ELSE NULL::"text"
        END AS "status"
   FROM "user_comparison"
  ORDER BY ("abs"("difference")) DESC;


ALTER VIEW "public"."purchase_integrity_check" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."referral_commissions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "referrer_user_id" character varying(6),
    "referred_user_id" character varying(6),
    "purchase_id" "uuid",
    "commission_amount" numeric(10,2),
    "commission_rate" numeric(5,2),
    "level" integer DEFAULT 1,
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."referral_commissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."referrals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "referrer_user_id" character varying(6),
    "referred_user_id" character varying(6),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."referrals" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."reward_questions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "question" "text" NOT NULL,
    "option_a" "text" NOT NULL,
    "option_b" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    "created_by" "uuid"
);


ALTER TABLE "public"."reward_questions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."system_config" (
    "key" character varying(50) NOT NULL,
    "value" "text" NOT NULL,
    "description" "text",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "updated_by" "uuid"
);


ALTER TABLE "public"."system_config" OWNER TO "postgres";


COMMENT ON TABLE "public"."system_config" IS 'システム設定 - 新機能のON/OFF制御';



CREATE TABLE IF NOT EXISTS "public"."system_emails" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subject" "text" NOT NULL,
    "body" "text" NOT NULL,
    "from_name" "text" DEFAULT 'HASHPILOT'::"text",
    "from_email" "text" DEFAULT 'noreply@hashpilot.biz'::"text",
    "email_type" "text" NOT NULL,
    "sent_by" "text" NOT NULL,
    "target_group" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "system_emails_email_type_check" CHECK (("email_type" = ANY (ARRAY['broadcast'::"text", 'individual'::"text"]))),
    CONSTRAINT "valid_email_type" CHECK (("email_type" = ANY (ARRAY['broadcast'::"text", 'individual'::"text"])))
);


ALTER TABLE "public"."system_emails" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."system_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "log_type" "text" NOT NULL,
    "operation" "text",
    "user_id" "text",
    "details" "jsonb",
    "message" "text",
    "ip_address" "text",
    "user_agent" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."system_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."system_settings" (
    "id" integer DEFAULT 1 NOT NULL,
    "usdt_address_bep20" "text",
    "usdt_address_trc20" "text",
    "nft_price" numeric(10,2) DEFAULT 1100.00,
    "maintenance_mode" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "single_row" CHECK (("id" = 1))
);


ALTER TABLE "public"."system_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."test_affiliate_reward" (
    "id" integer NOT NULL,
    "user_id" "text" NOT NULL,
    "referral_user_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "level" integer NOT NULL,
    "reward_rate" numeric(4,3) NOT NULL,
    "base_profit" numeric(10,2) NOT NULL,
    "reward_amount" numeric(10,2) NOT NULL,
    "phase" character varying(10) NOT NULL,
    "is_paid" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "test_mode" boolean DEFAULT true,
    CONSTRAINT "test_affiliate_reward_level_check" CHECK (("level" = ANY (ARRAY[1, 2, 3]))),
    CONSTRAINT "test_affiliate_reward_phase_check" CHECK ((("phase")::"text" = ANY ((ARRAY['USDT'::character varying, 'HOLD'::character varying])::"text"[])))
);


ALTER TABLE "public"."test_affiliate_reward" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."test_affiliate_reward_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."test_affiliate_reward_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."test_affiliate_reward_id_seq" OWNED BY "public"."test_affiliate_reward"."id";



CREATE TABLE IF NOT EXISTS "public"."test_company_daily_profit" (
    "id" integer NOT NULL,
    "date" "date" NOT NULL,
    "total_user_profit" numeric(12,2) DEFAULT 0 NOT NULL,
    "total_company_profit" numeric(12,2) DEFAULT 0 NOT NULL,
    "margin_rate" numeric(3,2) NOT NULL,
    "total_base_amount" numeric(12,2) DEFAULT 0 NOT NULL,
    "user_count" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "test_mode" boolean DEFAULT true
);


ALTER TABLE "public"."test_company_daily_profit" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."test_company_daily_profit_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."test_company_daily_profit_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."test_company_daily_profit_id_seq" OWNED BY "public"."test_company_daily_profit"."id";



CREATE TABLE IF NOT EXISTS "public"."test_daily_yield_log" (
    "id" integer NOT NULL,
    "date" "date" NOT NULL,
    "yield_rate" numeric(5,4) NOT NULL,
    "margin_rate" numeric(3,2) NOT NULL,
    "user_rate" numeric(5,4) NOT NULL,
    "is_month_end" boolean DEFAULT false,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "test_mode" boolean DEFAULT true
);


ALTER TABLE "public"."test_daily_yield_log" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."test_daily_yield_log_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."test_daily_yield_log_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."test_daily_yield_log_id_seq" OWNED BY "public"."test_daily_yield_log"."id";



CREATE TABLE IF NOT EXISTS "public"."test_user_daily_profit" (
    "id" integer NOT NULL,
    "user_id" "text" NOT NULL,
    "date" "date" NOT NULL,
    "yield_rate" numeric(5,4) NOT NULL,
    "user_rate" numeric(5,4) NOT NULL,
    "base_amount" numeric(10,2) NOT NULL,
    "daily_profit" numeric(10,2) NOT NULL,
    "phase" character varying(10) NOT NULL,
    "is_paid" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "test_mode" boolean DEFAULT true,
    CONSTRAINT "test_user_daily_profit_phase_check" CHECK ((("phase")::"text" = ANY ((ARRAY['USDT'::character varying, 'HOLD'::character varying])::"text"[])))
);


ALTER TABLE "public"."test_user_daily_profit" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."test_user_daily_profit_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."test_user_daily_profit_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."test_user_daily_profit_id_seq" OWNED BY "public"."test_user_daily_profit"."id";



CREATE OR REPLACE VIEW "public"."test_yield_summary" AS
 SELECT "tdyl"."date",
    "tdyl"."yield_rate",
    "tdyl"."margin_rate",
    "tdyl"."user_rate",
    "tcdp"."user_count" AS "total_users",
    "tcdp"."total_user_profit",
    "tcdp"."total_company_profit",
    COALESCE("tar_summary"."total_affiliate_rewards", (0)::numeric) AS "total_affiliate_rewards",
    "tdyl"."created_at"
   FROM (("public"."test_daily_yield_log" "tdyl"
     LEFT JOIN "public"."test_company_daily_profit" "tcdp" ON (("tdyl"."date" = "tcdp"."date")))
     LEFT JOIN ( SELECT "test_affiliate_reward"."date",
            "sum"("test_affiliate_reward"."reward_amount") AS "total_affiliate_rewards"
           FROM "public"."test_affiliate_reward"
          GROUP BY "test_affiliate_reward"."date") "tar_summary" ON (("tdyl"."date" = "tar_summary"."date")))
  ORDER BY "tdyl"."date" DESC;


ALTER VIEW "public"."test_yield_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."test_yield_summary" IS 'テスト結果の要約表示';



CREATE OR REPLACE VIEW "public"."user_daily_profit" AS
 SELECT "user_id",
    "date",
    "sum"("daily_profit") AS "daily_profit",
    "max"("yield_rate") AS "yield_rate",
    "max"("created_at") AS "created_at",
    NULL::numeric AS "base_amount",
    NULL::"text" AS "phase",
    NULL::numeric AS "user_rate"
   FROM "public"."nft_daily_profit" "ndp"
  GROUP BY "user_id", "date";


ALTER VIEW "public"."user_daily_profit" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_daily_profit_backup" (
    "id" integer,
    "user_id" "text",
    "date" "date",
    "yield_rate" numeric(5,4),
    "user_rate" numeric(5,4),
    "base_amount" numeric(10,2),
    "daily_profit" numeric(10,2),
    "phase" character varying(10),
    "is_paid" boolean,
    "created_at" timestamp with time zone,
    "personal_profit" numeric,
    "referral_profit" numeric,
    "updated_at" timestamp without time zone
);


ALTER TABLE "public"."user_daily_profit_backup" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_deletion_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deleted_user_id" "text" NOT NULL,
    "deleted_email" "text" NOT NULL,
    "admin_email" "text" NOT NULL,
    "deletion_reason" "text",
    "deleted_data" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_deletion_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_monthly_rewards" (
    "id" integer NOT NULL,
    "user_id" "text" NOT NULL,
    "year" integer NOT NULL,
    "month" integer NOT NULL,
    "total_daily_profit" numeric(10,2) DEFAULT 0 NOT NULL,
    "total_referral_rewards" numeric(10,2) DEFAULT 0 NOT NULL,
    "total_rewards" numeric(10,2) DEFAULT 0 NOT NULL,
    "is_paid" boolean DEFAULT false,
    "paid_at" timestamp with time zone,
    "paid_by" "text",
    "payment_transaction_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_monthly_rewards" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_monthly_rewards" IS 'ユーザー月次報酬サマリー';



CREATE SEQUENCE IF NOT EXISTS "public"."user_monthly_rewards_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."user_monthly_rewards_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."user_monthly_rewards_id_seq" OWNED BY "public"."user_monthly_rewards"."id";



CREATE OR REPLACE VIEW "public"."user_referral_profit_summary" AS
 SELECT "user_id",
    "date",
    "sum"("profit_amount") AS "total_referral_profit",
    "sum"(
        CASE
            WHEN ("referral_level" = 1) THEN "profit_amount"
            ELSE (0)::numeric
        END) AS "level1_profit",
    "sum"(
        CASE
            WHEN ("referral_level" = 2) THEN "profit_amount"
            ELSE (0)::numeric
        END) AS "level2_profit",
    "sum"(
        CASE
            WHEN ("referral_level" = 3) THEN "profit_amount"
            ELSE (0)::numeric
        END) AS "level3_profit",
    "count"(DISTINCT "child_user_id") AS "unique_children"
   FROM "public"."user_referral_profit"
  GROUP BY "user_id", "date";


ALTER VIEW "public"."user_referral_profit_summary" OWNER TO "postgres";


COMMENT ON VIEW "public"."user_referral_profit_summary" IS 'ユーザーの日次紹介報酬サマリー';



CREATE OR REPLACE VIEW "public"."user_total_referral_profit" AS
 SELECT "user_id",
    "sum"("profit_amount") AS "total_referral_profit",
    "sum"(
        CASE
            WHEN ("referral_level" = 1) THEN "profit_amount"
            ELSE (0)::numeric
        END) AS "total_level1_profit",
    "sum"(
        CASE
            WHEN ("referral_level" = 2) THEN "profit_amount"
            ELSE (0)::numeric
        END) AS "total_level2_profit",
    "sum"(
        CASE
            WHEN ("referral_level" = 3) THEN "profit_amount"
            ELSE (0)::numeric
        END) AS "total_level3_profit",
    "count"(DISTINCT "date") AS "days_with_referral",
    "count"(DISTINCT "child_user_id") AS "total_unique_children",
    "min"("date") AS "first_referral_date",
    "max"("date") AS "last_referral_date"
   FROM "public"."user_referral_profit"
  GROUP BY "user_id";


ALTER VIEW "public"."user_total_referral_profit" OWNER TO "postgres";


COMMENT ON VIEW "public"."user_total_referral_profit" IS 'ユーザーの累計紹介報酬';



CREATE TABLE IF NOT EXISTS "public"."user_withdrawal_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "text" NOT NULL,
    "withdrawal_address" "text",
    "coinw_uid" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_withdrawal_settings" OWNER TO "postgres";


ALTER TABLE ONLY "public"."affiliate_cycle" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."affiliate_cycle_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."affiliate_reward" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."affiliate_reward_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."company_daily_profit" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."company_daily_profit_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."daily_yield_log" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."daily_yield_log_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."nft_holdings" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."nft_holdings_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."test_affiliate_reward" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."test_affiliate_reward_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."test_company_daily_profit" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."test_company_daily_profit_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."test_daily_yield_log" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."test_daily_yield_log_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."test_user_daily_profit" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."test_user_daily_profit_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."user_monthly_rewards" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."user_monthly_rewards_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."admins"
    ADD CONSTRAINT "admins_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."admins"
    ADD CONSTRAINT "admins_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."affiliate_cycle"
    ADD CONSTRAINT "affiliate_cycle_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."affiliate_cycle"
    ADD CONSTRAINT "affiliate_cycle_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."affiliate_reward"
    ADD CONSTRAINT "affiliate_reward_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."affiliate_reward"
    ADD CONSTRAINT "affiliate_reward_user_id_referral_user_id_date_level_key" UNIQUE ("user_id", "referral_user_id", "date", "level");



ALTER TABLE ONLY "public"."buyback_requests"
    ADD CONSTRAINT "buyback_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_bonus_from_dormant"
    ADD CONSTRAINT "company_bonus_from_dormant_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."company_daily_profit"
    ADD CONSTRAINT "company_daily_profit_date_key" UNIQUE ("date");



ALTER TABLE ONLY "public"."company_daily_profit"
    ADD CONSTRAINT "company_daily_profit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."daily_yield_log"
    ADD CONSTRAINT "daily_yield_log_date_key" UNIQUE ("date");



ALTER TABLE ONLY "public"."daily_yield_log"
    ADD CONSTRAINT "daily_yield_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."email_recipients"
    ADD CONSTRAINT "email_recipients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."email_templates"
    ADD CONSTRAINT "email_templates_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."email_templates"
    ADD CONSTRAINT "email_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."monthly_reward_tasks"
    ADD CONSTRAINT "monthly_reward_tasks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."monthly_withdrawals"
    ADD CONSTRAINT "monthly_withdrawals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."monthly_withdrawals"
    ADD CONSTRAINT "monthly_withdrawals_user_id_withdrawal_month_key" UNIQUE ("user_id", "withdrawal_month");



ALTER TABLE ONLY "public"."nft_daily_profit"
    ADD CONSTRAINT "nft_daily_profit_nft_id_date_key" UNIQUE ("nft_id", "date");



ALTER TABLE ONLY "public"."nft_daily_profit"
    ADD CONSTRAINT "nft_daily_profit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nft_holdings"
    ADD CONSTRAINT "nft_holdings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nft_master"
    ADD CONSTRAINT "nft_master_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."nft_master"
    ADD CONSTRAINT "nft_master_user_id_nft_sequence_key" UNIQUE ("user_id", "nft_sequence");



ALTER TABLE ONLY "public"."nft_referral_profit"
    ADD CONSTRAINT "nft_referral_profit_nft_id_date_key" UNIQUE ("nft_id", "date");



ALTER TABLE ONLY "public"."nft_referral_profit"
    ADD CONSTRAINT "nft_referral_profit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."purchases"
    ADD CONSTRAINT "purchases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referral_commissions"
    ADD CONSTRAINT "referral_commissions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_referrer_user_id_referred_user_id_key" UNIQUE ("referrer_user_id", "referred_user_id");



ALTER TABLE ONLY "public"."reward_questions"
    ADD CONSTRAINT "reward_questions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_config"
    ADD CONSTRAINT "system_config_pkey" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."system_emails"
    ADD CONSTRAINT "system_emails_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_logs"
    ADD CONSTRAINT "system_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."system_settings"
    ADD CONSTRAINT "system_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."test_affiliate_reward"
    ADD CONSTRAINT "test_affiliate_reward_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."test_affiliate_reward"
    ADD CONSTRAINT "test_affiliate_reward_user_id_referral_user_id_date_level_key" UNIQUE ("user_id", "referral_user_id", "date", "level");



ALTER TABLE ONLY "public"."test_company_daily_profit"
    ADD CONSTRAINT "test_company_daily_profit_date_key" UNIQUE ("date");



ALTER TABLE ONLY "public"."test_company_daily_profit"
    ADD CONSTRAINT "test_company_daily_profit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."test_daily_yield_log"
    ADD CONSTRAINT "test_daily_yield_log_date_key" UNIQUE ("date");



ALTER TABLE ONLY "public"."test_daily_yield_log"
    ADD CONSTRAINT "test_daily_yield_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."test_user_daily_profit"
    ADD CONSTRAINT "test_user_daily_profit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."test_user_daily_profit"
    ADD CONSTRAINT "test_user_daily_profit_user_id_date_key" UNIQUE ("user_id", "date");



ALTER TABLE ONLY "public"."monthly_reward_tasks"
    ADD CONSTRAINT "unique_user_month" UNIQUE ("user_id", "year", "month");



ALTER TABLE ONLY "public"."user_deletion_logs"
    ADD CONSTRAINT "user_deletion_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_monthly_rewards"
    ADD CONSTRAINT "user_monthly_rewards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_monthly_rewards"
    ADD CONSTRAINT "user_monthly_rewards_user_id_year_month_key" UNIQUE ("user_id", "year", "month");



ALTER TABLE ONLY "public"."user_referral_profit"
    ADD CONSTRAINT "user_referral_profit_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_withdrawal_settings"
    ADD CONSTRAINT "user_withdrawal_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_withdrawal_settings"
    ADD CONSTRAINT "user_withdrawal_settings_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_user_id_key" UNIQUE ("user_id");



CREATE INDEX "idx_affiliate_cycle_user_id" ON "public"."affiliate_cycle" USING "btree" ("user_id");



CREATE INDEX "idx_affiliate_reward_referral_date" ON "public"."affiliate_reward" USING "btree" ("referral_user_id", "date");



CREATE INDEX "idx_affiliate_reward_user_date" ON "public"."affiliate_reward" USING "btree" ("user_id", "date");



CREATE INDEX "idx_buyback_requests_created_at" ON "public"."buyback_requests" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_buyback_requests_status" ON "public"."buyback_requests" USING "btree" ("status");



CREATE INDEX "idx_buyback_requests_user_id" ON "public"."buyback_requests" USING "btree" ("user_id");



CREATE INDEX "idx_company_bonus_child_user" ON "public"."company_bonus_from_dormant" USING "btree" ("child_user_id");



CREATE INDEX "idx_company_bonus_date" ON "public"."company_bonus_from_dormant" USING "btree" ("date");



CREATE INDEX "idx_company_bonus_dormant_user" ON "public"."company_bonus_from_dormant" USING "btree" ("dormant_user_id");



CREATE INDEX "idx_company_daily_profit_date" ON "public"."company_daily_profit" USING "btree" ("date");



CREATE INDEX "idx_daily_yield_log_date" ON "public"."daily_yield_log" USING "btree" ("date");



CREATE INDEX "idx_email_recipients_created_at" ON "public"."email_recipients" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_email_recipients_email_id" ON "public"."email_recipients" USING "btree" ("email_id");



CREATE INDEX "idx_email_recipients_status" ON "public"."email_recipients" USING "btree" ("status");



CREATE INDEX "idx_email_recipients_user_id" ON "public"."email_recipients" USING "btree" ("user_id");



CREATE INDEX "idx_monthly_reward_tasks_completed" ON "public"."monthly_reward_tasks" USING "btree" ("is_completed", "year", "month");



CREATE INDEX "idx_monthly_reward_tasks_user_month" ON "public"."monthly_reward_tasks" USING "btree" ("user_id", "year", "month");



CREATE INDEX "idx_monthly_withdrawals_month" ON "public"."monthly_withdrawals" USING "btree" ("withdrawal_month");



CREATE INDEX "idx_monthly_withdrawals_status" ON "public"."monthly_withdrawals" USING "btree" ("status");



CREATE INDEX "idx_monthly_withdrawals_task_status" ON "public"."monthly_withdrawals" USING "btree" ("task_completed");



CREATE INDEX "idx_monthly_withdrawals_user" ON "public"."monthly_withdrawals" USING "btree" ("user_id");



CREATE INDEX "idx_nft_daily_profit_date" ON "public"."nft_daily_profit" USING "btree" ("date");



CREATE INDEX "idx_nft_daily_profit_nft_id" ON "public"."nft_daily_profit" USING "btree" ("nft_id");



CREATE INDEX "idx_nft_daily_profit_user_date" ON "public"."nft_daily_profit" USING "btree" ("user_id", "date");



CREATE INDEX "idx_nft_holdings_type" ON "public"."nft_holdings" USING "btree" ("nft_type");



CREATE INDEX "idx_nft_holdings_user_id" ON "public"."nft_holdings" USING "btree" ("user_id");



CREATE INDEX "idx_nft_master_buyback" ON "public"."nft_master" USING "btree" ("buyback_date") WHERE ("buyback_date" IS NULL);



CREATE INDEX "idx_nft_master_user_id" ON "public"."nft_master" USING "btree" ("user_id");



CREATE INDEX "idx_nft_referral_profit_nft_id" ON "public"."nft_referral_profit" USING "btree" ("nft_id");



CREATE INDEX "idx_nft_referral_profit_user_date" ON "public"."nft_referral_profit" USING "btree" ("user_id", "date");



CREATE INDEX "idx_reward_questions_active" ON "public"."reward_questions" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_system_emails_created_at" ON "public"."system_emails" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_system_emails_sent_by" ON "public"."system_emails" USING "btree" ("sent_by");



CREATE INDEX "idx_system_logs_created_at" ON "public"."system_logs" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_system_logs_log_type" ON "public"."system_logs" USING "btree" ("log_type");



CREATE INDEX "idx_system_logs_operation" ON "public"."system_logs" USING "btree" ("operation");



CREATE INDEX "idx_system_logs_user_id" ON "public"."system_logs" USING "btree" ("user_id");



CREATE INDEX "idx_user_monthly_rewards_is_paid" ON "public"."user_monthly_rewards" USING "btree" ("is_paid");



CREATE INDEX "idx_user_monthly_rewards_user_year_month" ON "public"."user_monthly_rewards" USING "btree" ("user_id", "year", "month");



CREATE INDEX "idx_user_referral_profit_child" ON "public"."user_referral_profit" USING "btree" ("child_user_id");



CREATE INDEX "idx_user_referral_profit_date" ON "public"."user_referral_profit" USING "btree" ("date");



CREATE UNIQUE INDEX "idx_user_referral_profit_unique" ON "public"."user_referral_profit" USING "btree" ("user_id", "date", "referral_level", "child_user_id");



CREATE INDEX "idx_user_referral_profit_user_date" ON "public"."user_referral_profit" USING "btree" ("user_id", "date");



CREATE INDEX "idx_users_active_investor" ON "public"."users" USING "btree" ("is_active_investor") WHERE ("is_active_investor" = true);



CREATE INDEX "idx_users_email_blacklisted" ON "public"."users" USING "btree" ("email_blacklisted") WHERE ("email_blacklisted" = true);



CREATE INDEX "idx_users_nft_address" ON "public"."users" USING "btree" ("nft_address");



CREATE INDEX "idx_users_nft_distributed" ON "public"."users" USING "btree" ("nft_distributed");



CREATE INDEX "idx_users_nft_distributed_at" ON "public"."users" USING "btree" ("nft_distributed_at");



CREATE INDEX "idx_users_nft_sent" ON "public"."users" USING "btree" ("nft_sent");



CREATE INDEX "idx_users_pegasus_exchange" ON "public"."users" USING "btree" ("is_pegasus_exchange") WHERE ("is_pegasus_exchange" = true);



CREATE INDEX "idx_users_reward_address" ON "public"."users" USING "btree" ("reward_address_bep20");



CREATE OR REPLACE TRIGGER "check_nft_update_trigger" AFTER UPDATE OF "total_nft_count" ON "public"."affiliate_cycle" FOR EACH ROW EXECUTE FUNCTION "public"."check_nft_update"();



CREATE OR REPLACE TRIGGER "trigger_set_active_on_purchase" AFTER INSERT ON "public"."nft_master" FOR EACH ROW EXECUTE FUNCTION "public"."set_user_active_on_nft_purchase"();



CREATE OR REPLACE TRIGGER "trigger_update_active_status" AFTER UPDATE OF "buyback_date" ON "public"."nft_master" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_active_status"();



CREATE OR REPLACE TRIGGER "update_buyback_requests_updated_at" BEFORE UPDATE ON "public"."buyback_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



ALTER TABLE ONLY "public"."affiliate_cycle"
    ADD CONSTRAINT "affiliate_cycle_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."affiliate_reward"
    ADD CONSTRAINT "affiliate_reward_referral_user_id_fkey" FOREIGN KEY ("referral_user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."affiliate_reward"
    ADD CONSTRAINT "affiliate_reward_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."daily_yield_log"
    ADD CONSTRAINT "daily_yield_log_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."email_recipients"
    ADD CONSTRAINT "email_recipients_email_id_fkey" FOREIGN KEY ("email_id") REFERENCES "public"."system_emails"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."email_recipients"
    ADD CONSTRAINT "email_recipients_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."monthly_withdrawals"
    ADD CONSTRAINT "fk_monthly_withdrawals_user" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."monthly_reward_tasks"
    ADD CONSTRAINT "fk_user_monthly_tasks" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."nft_daily_profit"
    ADD CONSTRAINT "nft_daily_profit_nft_id_fkey" FOREIGN KEY ("nft_id") REFERENCES "public"."nft_master"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."nft_holdings"
    ADD CONSTRAINT "nft_holdings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."nft_referral_profit"
    ADD CONSTRAINT "nft_referral_profit_nft_id_fkey" FOREIGN KEY ("nft_id") REFERENCES "public"."nft_master"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_purchase_id_fkey" FOREIGN KEY ("purchase_id") REFERENCES "public"."purchases"("id");



ALTER TABLE ONLY "public"."purchases"
    ADD CONSTRAINT "purchases_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."referral_commissions"
    ADD CONSTRAINT "referral_commissions_purchase_id_fkey" FOREIGN KEY ("purchase_id") REFERENCES "public"."purchases"("id");



ALTER TABLE ONLY "public"."referral_commissions"
    ADD CONSTRAINT "referral_commissions_referred_user_id_fkey" FOREIGN KEY ("referred_user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."referral_commissions"
    ADD CONSTRAINT "referral_commissions_referrer_user_id_fkey" FOREIGN KEY ("referrer_user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_referred_user_id_fkey" FOREIGN KEY ("referred_user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."referrals"
    ADD CONSTRAINT "referrals_referrer_user_id_fkey" FOREIGN KEY ("referrer_user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."reward_questions"
    ADD CONSTRAINT "reward_questions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."system_config"
    ADD CONSTRAINT "system_config_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."test_daily_yield_log"
    ADD CONSTRAINT "test_daily_yield_log_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."user_monthly_rewards"
    ADD CONSTRAINT "user_monthly_rewards_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."user_withdrawal_settings"
    ADD CONSTRAINT "user_withdrawal_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_referrer_user_id_fkey" FOREIGN KEY ("referrer_user_id") REFERENCES "public"."users"("user_id");



CREATE POLICY "Admin can manage system settings" ON "public"."system_settings" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE (("admins"."email" = ("auth"."jwt"() ->> 'email'::"text")) AND ("admins"."is_active" = true)))));



CREATE POLICY "Admin only access to deletion logs" ON "public"."user_deletion_logs" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."email" = ("auth"."jwt"() ->> 'email'::"text")))));



CREATE POLICY "Admins can update all buyback requests" ON "public"."buyback_requests" FOR UPDATE USING (((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))) OR ("auth"."email"() = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text", 'masataka.tak@gmail.com'::"text"]))));



CREATE POLICY "Admins can view all affiliate cycles" ON "public"."affiliate_cycle" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))) OR ("auth"."email"() = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text", 'masataka.tak@gmail.com'::"text"]))));



CREATE POLICY "Admins can view all buyback requests" ON "public"."buyback_requests" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))) OR ("auth"."email"() = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text", 'masataka.tak@gmail.com'::"text"]))));



CREATE POLICY "Admins can view all data" ON "public"."users" TO "authenticated" USING ("public"."is_admin"(("auth"."jwt"() ->> 'email'::"text"), "auth"."uid"()));



CREATE POLICY "Admins can view all logs" ON "public"."system_logs" FOR SELECT USING (((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))) OR ("auth"."email"() = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text", 'masataka.tak@gmail.com'::"text"]))));



CREATE POLICY "Admins can view all purchases" ON "public"."purchases" TO "authenticated" USING ("public"."is_admin"(("auth"."jwt"() ->> 'email'::"text"), "auth"."uid"()));



CREATE POLICY "Allow admin insert/update on daily_yield_log" ON "public"."daily_yield_log" USING ((("auth"."jwt"() ->> 'email'::"text") = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text"]))) WITH CHECK ((("auth"."jwt"() ->> 'email'::"text") = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text"])));



CREATE POLICY "Everyone can read system settings" ON "public"."system_settings" FOR SELECT USING (true);



CREATE POLICY "Users can create their own buyback requests" ON "public"."buyback_requests" FOR INSERT WITH CHECK (("user_id" = ("auth"."uid"())::"text"));



CREATE POLICY "Users can insert their own logs" ON "public"."system_logs" FOR INSERT WITH CHECK ((("user_id" = ("auth"."uid"())::"text") OR ("user_id" IS NULL)));



CREATE POLICY "Users can update their own affiliate cycle" ON "public"."affiliate_cycle" FOR UPDATE USING (("user_id" = ("auth"."uid"())::"text"));



CREATE POLICY "Users can update their own buyback requests" ON "public"."buyback_requests" FOR UPDATE USING (("user_id" = ("auth"."uid"())::"text"));



CREATE POLICY "Users can view referrals" ON "public"."referrals" FOR SELECT USING (((("referrer_user_id")::"text" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))) OR (("referred_user_id")::"text" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"())))));



CREATE POLICY "Users can view their own affiliate cycle" ON "public"."affiliate_cycle" FOR SELECT USING (("user_id" = ("auth"."uid"())::"text"));



CREATE POLICY "Users can view their own buyback requests" ON "public"."buyback_requests" FOR SELECT USING (("user_id" = ("auth"."uid"())::"text"));



CREATE POLICY "Users can view their own cycle data" ON "public"."affiliate_cycle" FOR SELECT TO "authenticated" USING (((("auth"."uid"())::"text" = "user_id") OR ("user_id" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"())))));



CREATE POLICY "admin_access_system_logs" ON "public"."system_logs" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE (("admins"."email" IN ( SELECT "users"."email"
           FROM "auth"."users"
          WHERE ("users"."id" = "auth"."uid"()))) AND ("admins"."is_active" = true)))));



CREATE POLICY "admin_all_buyback_requests" ON "public"."buyback_requests" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE (("admins"."email" IN ( SELECT "users"."email"
           FROM "auth"."users"
          WHERE ("users"."id" = "auth"."uid"()))) AND ("admins"."is_active" = true)))));



CREATE POLICY "admin_all_withdrawals" ON "public"."monthly_withdrawals" TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text", 'masataka.tak@gmail.com'::"text"])));



CREATE POLICY "admin_manage_questions" ON "public"."reward_questions" TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text"])));



CREATE POLICY "admin_view_all_tasks" ON "public"."monthly_reward_tasks" FOR SELECT TO "authenticated" USING ((("auth"."jwt"() ->> 'email'::"text") = ANY (ARRAY['basarasystems@gmail.com'::"text", 'support@dshsupport.biz'::"text"])));



ALTER TABLE "public"."admins" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."affiliate_cycle" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "affiliate_cycle_select" ON "public"."affiliate_cycle" FOR SELECT USING ((("user_id" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))) OR (EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text")))));



CREATE POLICY "affiliate_cycle_update" ON "public"."affiliate_cycle" FOR UPDATE USING ((("user_id" = ("auth"."uid"())::"text") OR (EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text")))));



ALTER TABLE "public"."affiliate_reward" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "affiliate_reward_select" ON "public"."affiliate_reward" FOR SELECT USING ((("user_id" = ("auth"."uid"())::"text") OR (EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text")))));



CREATE POLICY "allow_all_affiliate_cycle_read" ON "public"."affiliate_cycle" FOR SELECT USING (true);



CREATE POLICY "allow_all_users_read" ON "public"."users" FOR SELECT USING (true);



ALTER TABLE "public"."buyback_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."company_daily_profit" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "company_daily_profit_select" ON "public"."company_daily_profit" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."daily_yield_log" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "daily_yield_log_insert" ON "public"."daily_yield_log" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



CREATE POLICY "daily_yield_log_select" ON "public"."daily_yield_log" FOR SELECT USING (true);



ALTER TABLE "public"."email_recipients" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."email_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."monthly_reward_tasks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."monthly_withdrawals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."nft_holdings" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "nft_holdings_insert" ON "public"."nft_holdings" FOR INSERT WITH CHECK ((("user_id" = ("auth"."uid"())::"text") OR (EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text")))));



CREATE POLICY "nft_holdings_select" ON "public"."nft_holdings" FOR SELECT USING ((("user_id" = ("auth"."uid"())::"text") OR (EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text")))));



ALTER TABLE "public"."payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."purchases" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referral_commissions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."referrals" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."reward_questions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "simple_admins_policy" ON "public"."admins" TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "simple_purchases_policy" ON "public"."purchases" TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "simple_users_policy" ON "public"."users" TO "authenticated" USING (true) WITH CHECK (true);



ALTER TABLE "public"."system_config" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "system_config_select" ON "public"."system_config" FOR SELECT USING (true);



CREATE POLICY "system_config_update" ON "public"."system_config" FOR UPDATE WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."system_emails" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."system_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."test_affiliate_reward" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "test_affiliate_reward_admin_only" ON "public"."test_affiliate_reward" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."test_company_daily_profit" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "test_company_profit_admin_only" ON "public"."test_company_daily_profit" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."test_daily_yield_log" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "test_tables_admin_only" ON "public"."test_daily_yield_log" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."test_user_daily_profit" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "test_user_profit_admin_only" ON "public"."test_user_daily_profit" USING ((EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text"))));



ALTER TABLE "public"."user_deletion_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_monthly_rewards" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_monthly_rewards_select" ON "public"."user_monthly_rewards" FOR SELECT USING ((("user_id" = ("auth"."uid"())::"text") OR (EXISTS ( SELECT 1
   FROM "public"."admins"
  WHERE ("admins"."user_id" = ("auth"."uid"())::"text")))));



ALTER TABLE "public"."user_withdrawal_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "users_create_own_buyback_requests" ON "public"."buyback_requests" FOR INSERT WITH CHECK (("user_id" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "users_own_buyback_requests" ON "public"."buyback_requests" FOR SELECT USING (("user_id" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "users_own_tasks" ON "public"."monthly_reward_tasks" TO "authenticated" USING ((("user_id")::"text" = (( SELECT "u"."user_id"
   FROM "public"."users" "u"
  WHERE (("u"."email")::"text" = ("auth"."jwt"() ->> 'email'::"text"))))::"text"));



CREATE POLICY "users_own_withdrawal_settings" ON "public"."user_withdrawal_settings" USING (("user_id" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "users_own_withdrawals" ON "public"."monthly_withdrawals" FOR SELECT USING (("user_id" IN ( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE ("users"."id" = "auth"."uid"()))));



CREATE POLICY "users_read_questions" ON "public"."reward_questions" FOR SELECT TO "authenticated" USING (("is_active" = true));



CREATE POLICY "ユーザーは自分のメールの既読状態を更新可能" ON "public"."email_recipients" FOR UPDATE USING (("user_id" = (( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE (("users"."email")::"text" = ("auth"."jwt"() ->> 'email'::"text"))))::"text"));



CREATE POLICY "ユーザーは自分宛てのメールのみ参照可能" ON "public"."email_recipients" FOR SELECT USING (("user_id" = (( SELECT "users"."user_id"
   FROM "public"."users"
  WHERE (("users"."email")::"text" = ("auth"."jwt"() ->> 'email'::"text"))))::"text"));



CREATE POLICY "管理者のみテンプレート作成可能" ON "public"."email_templates" FOR INSERT WITH CHECK ("public"."is_system_admin"(("auth"."jwt"() ->> 'email'::"text")));



CREATE POLICY "管理者のみテンプレート参照可能" ON "public"."email_templates" FOR SELECT USING ("public"."is_system_admin"(("auth"."jwt"() ->> 'email'::"text")));



CREATE POLICY "管理者は全てのメールを作成可能" ON "public"."system_emails" FOR INSERT WITH CHECK ("public"."is_system_admin"("sent_by"));



CREATE POLICY "管理者は全てのメールを参照可能" ON "public"."system_emails" FOR SELECT USING (("public"."is_system_admin"("sent_by") OR "public"."is_system_admin"(("auth"."jwt"() ->> 'email'::"text"))));



CREATE POLICY "管理者は全ての配信状況を参照可能" ON "public"."email_recipients" FOR SELECT USING ("public"."is_system_admin"(("auth"."jwt"() ->> 'email'::"text")));



CREATE POLICY "管理者は配信レコードを作成可能" ON "public"."email_recipients" FOR INSERT WITH CHECK ("public"."is_system_admin"(("auth"."jwt"() ->> 'email'::"text")));



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_cancel_yield_posting"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_cancel_yield_posting"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_cancel_yield_posting"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_cancel_yield_posting_v2"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_cancel_yield_posting_v2"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_cancel_yield_posting_v2"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_check_affiliate_cycle_data"("p_admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_check_affiliate_cycle_data"("p_admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_check_affiliate_cycle_data"("p_admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_clear_test_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."admin_clear_test_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_clear_test_data"() TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_generate_daily_profit_data"("p_admin_email" "text", "p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_generate_daily_profit_data"("p_admin_email" "text", "p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_generate_daily_profit_data"("p_admin_email" "text", "p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_get_migration_stats"("p_admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_get_migration_stats"("p_admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_get_migration_stats"("p_admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_migrate_purchases_to_affiliate_cycle"("p_admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."admin_migrate_purchases_to_affiliate_cycle"("p_admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_migrate_purchases_to_affiliate_cycle"("p_admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_post_yield_test_mode"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."admin_post_yield_test_mode"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_post_yield_test_mode"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."admin_test_yield_calculation"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."admin_test_yield_calculation"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."admin_test_yield_calculation"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_nft_purchase_safe"("p_purchase_id" "uuid", "p_admin_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_nft_purchase_safe"("p_purchase_id" "uuid", "p_admin_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_nft_purchase_safe"("p_purchase_id" "uuid", "p_admin_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."approve_user_nft"("p_purchase_id" "text", "p_admin_email" "text", "p_admin_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."approve_user_nft"("p_purchase_id" "text", "p_admin_email" "text", "p_admin_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."approve_user_nft"("p_purchase_id" "text", "p_admin_email" "text", "p_admin_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_fix_nft_discrepancies"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_fix_nft_discrepancies"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_fix_nft_discrepancies"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_and_distribute_referral_bonuses"("p_user_id" "text", "p_personal_profit" numeric, "p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_and_distribute_referral_bonuses"("p_user_id" "text", "p_personal_profit" numeric, "p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_and_distribute_referral_bonuses"("p_user_id" "text", "p_personal_profit" numeric, "p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_buyback_preview"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_buyback_preview"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_buyback_preview"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_daily_profit_with_purchase_date_check"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_daily_profit_with_purchase_date_check"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_daily_profit_with_purchase_date_check"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_daily_referral_rewards"("p_user_id" character varying, "p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_daily_referral_rewards"("p_user_id" character varying, "p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_daily_referral_rewards"("p_user_id" character varying, "p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_monthly_rewards"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_monthly_rewards"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_monthly_rewards"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_nft_buyback_amount"("p_nft_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_nft_buyback_amount"("p_nft_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_nft_buyback_amount"("p_nft_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_operation_start_date"("p_approved_at" timestamp with time zone) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_operation_start_date"("p_approved_at" timestamp with time zone) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_operation_start_date"("p_approved_at" timestamp with time zone) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_referral_rewards_with_dormant"("p_date" "date", "p_is_test_mode" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_referral_rewards_with_dormant"("p_date" "date", "p_is_test_mode" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_referral_rewards_with_dormant"("p_date" "date", "p_is_test_mode" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_user_all_nft_buyback"("p_user_id" "text", "p_nft_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_user_all_nft_buyback"("p_user_id" "text", "p_nft_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_user_all_nft_buyback"("p_user_id" "text", "p_nft_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."cancel_yield_posting"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."cancel_yield_posting"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."cancel_yield_posting"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."change_user_referrer"("target_user_id" character varying, "new_referrer_id" character varying, "admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."change_user_referrer"("target_user_id" character varying, "new_referrer_id" character varying, "admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."change_user_referrer"("target_user_id" character varying, "new_referrer_id" character varying, "admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_cycle_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_cycle_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_cycle_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_max_referral_level"("target_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."check_max_referral_level"("target_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_max_referral_level"("target_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_monthly_withdrawal_candidates"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_monthly_withdrawal_candidates"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_monthly_withdrawal_candidates"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_nft_discrepancies"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_nft_discrepancies"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_nft_discrepancies"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_nft_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_nft_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_nft_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_yield_posting_impact"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."check_yield_posting_impact"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_yield_posting_impact"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_reward_task"("p_user_id" character varying, "p_answers" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."complete_reward_task"("p_user_id" character varying, "p_answers" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_reward_task"("p_user_id" character varying, "p_answers" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_withdrawal"("p_withdrawal_id" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."complete_withdrawal"("p_withdrawal_id" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_withdrawal"("p_withdrawal_id" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_withdrawals_batch"("p_withdrawal_ids" integer[]) TO "anon";
GRANT ALL ON FUNCTION "public"."complete_withdrawals_batch"("p_withdrawal_ids" integer[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_withdrawals_batch"("p_withdrawal_ids" integer[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_buyback_request"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer, "p_wallet_address" "text", "p_wallet_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_buyback_request"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer, "p_wallet_address" "text", "p_wallet_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_buyback_request"("p_user_id" "text", "p_manual_nft_count" integer, "p_auto_nft_count" integer, "p_wallet_address" "text", "p_wallet_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_monthly_reward_tasks"("p_year" integer, "p_month" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."create_monthly_reward_tasks"("p_year" integer, "p_month" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_monthly_reward_tasks"("p_year" integer, "p_month" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_send_to" "text", "p_individual_user_ids" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_send_to" "text", "p_individual_user_ids" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_send_to" "text", "p_individual_user_ids" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_email_type" "text", "p_admin_email" "text", "p_target_group" "text", "p_target_user_ids" "text"[]) TO "anon";
GRANT ALL ON FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_email_type" "text", "p_admin_email" "text", "p_target_group" "text", "p_target_user_ids" "text"[]) TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_system_email"("p_subject" "text", "p_body" "text", "p_email_type" "text", "p_admin_email" "text", "p_target_group" "text", "p_target_user_ids" "text"[]) TO "service_role";



GRANT ALL ON FUNCTION "public"."create_withdrawal_request"("p_user_id" "text", "p_amount" numeric, "p_wallet_address" "text", "p_wallet_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_withdrawal_request"("p_user_id" "text", "p_amount" numeric, "p_wallet_address" "text", "p_wallet_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_withdrawal_request"("p_user_id" "text", "p_amount" numeric, "p_wallet_address" "text", "p_wallet_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_purchase_record"("purchase_id" "uuid", "admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_purchase_record"("purchase_id" "uuid", "admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_purchase_record"("purchase_id" "uuid", "admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_user_completely"("target_user_id" character varying, "admin_user_id" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_completely"("target_user_id" character varying, "admin_user_id" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_completely"("target_user_id" character varying, "admin_user_id" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_user_completely"("target_user_id" "text", "admin_email" "text", "deletion_reason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_completely"("target_user_id" "text", "admin_email" "text", "deletion_reason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_completely"("target_user_id" "text", "admin_email" "text", "deletion_reason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_user_safely"("p_user_id" "text", "p_admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_safely"("p_user_id" "text", "p_admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_safely"("p_user_id" "text", "p_admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."fix_referral_data"() TO "anon";
GRANT ALL ON FUNCTION "public"."fix_referral_data"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fix_referral_data"() TO "service_role";



GRANT ALL ON FUNCTION "public"."fix_user_daily_profit_rls"() TO "anon";
GRANT ALL ON FUNCTION "public"."fix_user_daily_profit_rls"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."fix_user_daily_profit_rls"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_user_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_user_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_user_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_admin_list"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_admin_list"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_admin_list"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_admin_purchases"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_admin_purchases"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_admin_purchases"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_admin_users"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_admin_users"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_admin_users"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_all_buyback_requests"("p_status" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_all_buyback_requests"("p_status" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_all_buyback_requests"("p_status" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_auto_purchase_history"("p_user_id" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_auto_purchase_history"("p_user_id" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_auto_purchase_history"("p_user_id" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_buyback_requests"("p_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_buyback_requests"("p_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_buyback_requests"("p_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_company_bonus_report"("p_start_date" "date", "p_end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_company_bonus_report"("p_start_date" "date", "p_end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_company_bonus_report"("p_start_date" "date", "p_end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_deletion_logs"("limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_deletion_logs"("limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_deletion_logs"("limit_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_email_delivery_details"("p_email_id" "uuid", "p_admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_email_delivery_details"("p_email_id" "uuid", "p_admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_email_delivery_details"("p_email_id" "uuid", "p_admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_email_history"("p_admin_email" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_email_history"("p_admin_email" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_email_history"("p_admin_email" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_japan_date"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_japan_date"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_japan_date"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_japan_now"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_japan_now"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_japan_now"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_japan_year_month"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_japan_year_month"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_japan_year_month"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_max_referral_depth"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_max_referral_depth"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_max_referral_depth"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_month_end"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_month_end"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_month_end"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_month_start"("p_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_month_start"("p_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_month_start"("p_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_nft_distribution_summary"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_nft_distribution_summary"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_nft_distribution_summary"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_nft_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_nft_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_nft_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_payment_addresses"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_payment_addresses"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_payment_addresses"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_random_questions"("p_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_random_questions"("p_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_random_questions"("p_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_referral_profits"("p_user_id" "text", "p_date" "date", "p_month_start" "date", "p_month_end" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."get_referral_profits"("p_user_id" "text", "p_date" "date", "p_month_start" "date", "p_month_end" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_referral_profits"("p_user_id" "text", "p_date" "date", "p_month_start" "date", "p_month_end" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_referral_stats"("target_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_referral_stats"("target_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_referral_stats"("target_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_referral_tree"("root_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_referral_tree"("root_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_referral_tree"("root_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_referral_tree_revenue"("p_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_referral_tree_revenue"("p_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_referral_tree_revenue"("p_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_referral_tree_user"("root_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_referral_tree_user"("root_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_referral_tree_user"("root_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_system_logs"("p_limit" integer, "p_log_type" "text", "p_operation" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_system_logs"("p_limit" integer, "p_log_type" "text", "p_operation" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_system_logs"("p_limit" integer, "p_log_type" "text", "p_operation" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_system_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_system_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_system_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_daily_profit_stats"("p_user_id" "text", "p_days" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_daily_profit_stats"("p_user_id" "text", "p_days" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_daily_profit_stats"("p_user_id" "text", "p_days" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_deletion_info"("target_user_id" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_deletion_info"("target_user_id" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_deletion_info"("target_user_id" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_emails"("p_user_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_emails"("p_user_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_emails"("p_user_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_monthly_summary"("p_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_monthly_summary"("p_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_monthly_summary"("p_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_stats"("target_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_stats"("target_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_stats"("target_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_yield_posting_history"("p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_yield_posting_history"("p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_yield_posting_history"("p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_complete"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_complete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_complete"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_registration"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_with_coinw_uid"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_with_coinw_uid"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_with_coinw_uid"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_with_metadata"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_with_metadata"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_with_metadata"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"("user_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"("user_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"("user_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"("user_email" "text", "user_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"("user_email" "text", "user_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"("user_email" "text", "user_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_month_end"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_month_end"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_month_end"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_month_end_jst"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_month_end_jst"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_month_end_jst"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_month_start"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_month_start"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_month_start"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_system_admin"("p_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."is_system_admin"("p_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_system_admin"("p_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_user_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_user_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_user_admin"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_system_event"("p_log_type" "text", "p_operation" "text", "p_message" "text", "p_user_id" "text", "p_details" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."log_system_event"("p_log_type" "text", "p_operation" "text", "p_message" "text", "p_user_id" "text", "p_details" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_system_event"("p_log_type" "text", "p_operation" "text", "p_message" "text", "p_user_id" "text", "p_details" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."manual_coinw_uid_sync"() TO "anon";
GRANT ALL ON FUNCTION "public"."manual_coinw_uid_sync"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."manual_coinw_uid_sync"() TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_email_as_read"("p_email_id" "uuid", "p_user_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_email_as_read"("p_email_id" "uuid", "p_user_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_email_as_read"("p_email_id" "uuid", "p_user_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_nft_sent"("target_user_id" "text", "admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_nft_sent"("target_user_id" "text", "admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_nft_sent"("target_user_id" "text", "admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_reward_as_paid"("p_user_id" "text", "p_year" integer, "p_month" integer, "p_transaction_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_reward_as_paid"("p_user_id" "text", "p_year" integer, "p_month" integer, "p_transaction_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_reward_as_paid"("p_user_id" "text", "p_year" integer, "p_month" integer, "p_transaction_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."modify_yield_posting"("p_date" "date", "p_new_yield_rate" numeric, "p_new_margin_rate" numeric, "p_new_is_month_end" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."modify_yield_posting"("p_date" "date", "p_new_yield_rate" numeric, "p_new_margin_rate" numeric, "p_new_is_month_end" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."modify_yield_posting"("p_date" "date", "p_new_yield_rate" numeric, "p_new_margin_rate" numeric, "p_new_is_month_end" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."process_buyback_request"("p_request_id" "uuid", "p_action" "text", "p_transaction_hash" "text", "p_admin_notes" "text", "p_admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."process_buyback_request"("p_request_id" "uuid", "p_action" "text", "p_transaction_hash" "text", "p_admin_notes" "text", "p_admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_buyback_request"("p_request_id" "uuid", "p_action" "text", "p_transaction_hash" "text", "p_admin_notes" "text", "p_admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."process_daily_yield_with_cycles"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean, "p_skip_validation" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."process_daily_yield_with_cycles"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean, "p_skip_validation" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_daily_yield_with_cycles"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_test_mode" boolean, "p_skip_validation" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."process_monthly_auto_withdrawal"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_monthly_auto_withdrawal"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_monthly_auto_withdrawal"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_monthly_withdrawals"("p_target_month" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."process_monthly_withdrawals"("p_target_month" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_monthly_withdrawals"("p_target_month" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."set_user_active_on_nft_purchase"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_user_active_on_nft_purchase"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_user_active_on_nft_purchase"() TO "service_role";



GRANT ALL ON FUNCTION "public"."simple_admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."simple_admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."simple_admin_post_yield"("p_date" "date", "p_yield_rate" numeric, "p_margin_rate" numeric, "p_is_month_end" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."simulate_monthly_withdrawal"() TO "anon";
GRANT ALL ON FUNCTION "public"."simulate_monthly_withdrawal"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."simulate_monthly_withdrawal"() TO "service_role";



GRANT ALL ON FUNCTION "public"."simulate_user_monthly_process"("p_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."simulate_user_monthly_process"("p_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."simulate_user_monthly_process"("p_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_coinw_uid_from_auth"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_coinw_uid_from_auth"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_coinw_uid_from_auth"() TO "service_role";



GRANT ALL ON FUNCTION "public"."system_health_check"() TO "anon";
GRANT ALL ON FUNCTION "public"."system_health_check"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."system_health_check"() TO "service_role";



GRANT ALL ON FUNCTION "public"."test_monthly_auto_withdrawal"("p_force" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."test_monthly_auto_withdrawal"("p_force" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."test_monthly_auto_withdrawal"("p_force" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."test_update_nft_count"("p_user_id" "text", "p_manual_count" integer, "p_auto_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."test_update_nft_count"("p_user_id" "text", "p_manual_count" integer, "p_auto_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."test_update_nft_count"("p_user_id" "text", "p_manual_count" integer, "p_auto_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."text_to_html"("p_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."text_to_html"("p_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."text_to_html"("p_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_nft_distribution_status"("p_user_id" "text", "p_is_distributed" boolean, "p_admin_user_id" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_nft_distribution_status"("p_user_id" "text", "p_is_distributed" boolean, "p_admin_user_id" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_nft_distribution_status"("p_user_id" "text", "p_is_distributed" boolean, "p_admin_user_id" "text", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_user_active_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_active_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_active_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_user_addresses"("target_user_id" "text", "new_reward_address" "text", "new_nft_address" "text", "admin_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_addresses"("target_user_id" "text", "new_reward_address" "text", "new_nft_address" "text", "admin_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_addresses"("target_user_id" "text", "new_reward_address" "text", "new_nft_address" "text", "admin_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_user_purchase_total"("target_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_purchase_total"("target_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_purchase_total"("target_user_id" "text") TO "service_role";



GRANT ALL ON TABLE "public"."nft_master" TO "anon";
GRANT ALL ON TABLE "public"."nft_master" TO "authenticated";
GRANT ALL ON TABLE "public"."nft_master" TO "service_role";



GRANT ALL ON TABLE "public"."purchases" TO "anon";
GRANT ALL ON TABLE "public"."purchases" TO "authenticated";
GRANT ALL ON TABLE "public"."purchases" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";



GRANT ALL ON TABLE "public"."admin_auto_nft_grants_view" TO "anon";
GRANT ALL ON TABLE "public"."admin_auto_nft_grants_view" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_auto_nft_grants_view" TO "service_role";



GRANT ALL ON TABLE "public"."admin_purchases_view" TO "anon";
GRANT ALL ON TABLE "public"."admin_purchases_view" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_purchases_view" TO "service_role";



GRANT ALL ON TABLE "public"."admins" TO "anon";
GRANT ALL ON TABLE "public"."admins" TO "authenticated";
GRANT ALL ON TABLE "public"."admins" TO "service_role";



GRANT ALL ON TABLE "public"."affiliate_cycle" TO "anon";
GRANT ALL ON TABLE "public"."affiliate_cycle" TO "authenticated";
GRANT ALL ON TABLE "public"."affiliate_cycle" TO "service_role";



GRANT ALL ON SEQUENCE "public"."affiliate_cycle_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."affiliate_cycle_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."affiliate_cycle_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."affiliate_reward" TO "anon";
GRANT ALL ON TABLE "public"."affiliate_reward" TO "authenticated";
GRANT ALL ON TABLE "public"."affiliate_reward" TO "service_role";



GRANT ALL ON SEQUENCE "public"."affiliate_reward_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."affiliate_reward_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."affiliate_reward_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."backup_auth_users_metadata_20250706" TO "anon";
GRANT ALL ON TABLE "public"."backup_auth_users_metadata_20250706" TO "authenticated";
GRANT ALL ON TABLE "public"."backup_auth_users_metadata_20250706" TO "service_role";



GRANT ALL ON TABLE "public"."backup_problem_users_20250706" TO "anon";
GRANT ALL ON TABLE "public"."backup_problem_users_20250706" TO "authenticated";
GRANT ALL ON TABLE "public"."backup_problem_users_20250706" TO "service_role";



GRANT ALL ON TABLE "public"."backup_purchases_20250706" TO "anon";
GRANT ALL ON TABLE "public"."backup_purchases_20250706" TO "authenticated";
GRANT ALL ON TABLE "public"."backup_purchases_20250706" TO "service_role";



GRANT ALL ON TABLE "public"."backup_users_20250706" TO "anon";
GRANT ALL ON TABLE "public"."backup_users_20250706" TO "authenticated";
GRANT ALL ON TABLE "public"."backup_users_20250706" TO "service_role";



GRANT ALL ON TABLE "public"."buyback_requests" TO "anon";
GRANT ALL ON TABLE "public"."buyback_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."buyback_requests" TO "service_role";



GRANT ALL ON TABLE "public"."company_bonus_from_dormant" TO "anon";
GRANT ALL ON TABLE "public"."company_bonus_from_dormant" TO "authenticated";
GRANT ALL ON TABLE "public"."company_bonus_from_dormant" TO "service_role";



GRANT ALL ON TABLE "public"."user_referral_profit" TO "anon";
GRANT ALL ON TABLE "public"."user_referral_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."user_referral_profit" TO "service_role";



GRANT ALL ON TABLE "public"."company_account_referral_summary" TO "anon";
GRANT ALL ON TABLE "public"."company_account_referral_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."company_account_referral_summary" TO "service_role";



GRANT ALL ON TABLE "public"."company_bonus_summary" TO "anon";
GRANT ALL ON TABLE "public"."company_bonus_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."company_bonus_summary" TO "service_role";



GRANT ALL ON TABLE "public"."company_daily_profit" TO "anon";
GRANT ALL ON TABLE "public"."company_daily_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."company_daily_profit" TO "service_role";



GRANT ALL ON SEQUENCE "public"."company_daily_profit_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."company_daily_profit_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."company_daily_profit_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."daily_yield_log" TO "anon";
GRANT ALL ON TABLE "public"."daily_yield_log" TO "authenticated";
GRANT ALL ON TABLE "public"."daily_yield_log" TO "service_role";



GRANT ALL ON SEQUENCE "public"."daily_yield_log_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."daily_yield_log_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."daily_yield_log_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."dormant_users_list" TO "anon";
GRANT ALL ON TABLE "public"."dormant_users_list" TO "authenticated";
GRANT ALL ON TABLE "public"."dormant_users_list" TO "service_role";



GRANT ALL ON TABLE "public"."email_recipients" TO "anon";
GRANT ALL ON TABLE "public"."email_recipients" TO "authenticated";
GRANT ALL ON TABLE "public"."email_recipients" TO "service_role";



GRANT ALL ON TABLE "public"."email_templates" TO "anon";
GRANT ALL ON TABLE "public"."email_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."email_templates" TO "service_role";



GRANT ALL ON TABLE "public"."monthly_reward_tasks" TO "anon";
GRANT ALL ON TABLE "public"."monthly_reward_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."monthly_reward_tasks" TO "service_role";



GRANT ALL ON TABLE "public"."monthly_withdrawals" TO "anon";
GRANT ALL ON TABLE "public"."monthly_withdrawals" TO "authenticated";
GRANT ALL ON TABLE "public"."monthly_withdrawals" TO "service_role";



GRANT ALL ON TABLE "public"."nft_count_audit" TO "anon";
GRANT ALL ON TABLE "public"."nft_count_audit" TO "authenticated";
GRANT ALL ON TABLE "public"."nft_count_audit" TO "service_role";



GRANT ALL ON TABLE "public"."nft_daily_profit" TO "anon";
GRANT ALL ON TABLE "public"."nft_daily_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."nft_daily_profit" TO "service_role";



GRANT ALL ON TABLE "public"."nft_holdings" TO "anon";
GRANT ALL ON TABLE "public"."nft_holdings" TO "authenticated";
GRANT ALL ON TABLE "public"."nft_holdings" TO "service_role";



GRANT ALL ON SEQUENCE "public"."nft_holdings_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."nft_holdings_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."nft_holdings_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."nft_referral_profit" TO "anon";
GRANT ALL ON TABLE "public"."nft_referral_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."nft_referral_profit" TO "service_role";



GRANT ALL ON TABLE "public"."nft_total_profit" TO "anon";
GRANT ALL ON TABLE "public"."nft_total_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."nft_total_profit" TO "service_role";



GRANT ALL ON TABLE "public"."payments" TO "anon";
GRANT ALL ON TABLE "public"."payments" TO "authenticated";
GRANT ALL ON TABLE "public"."payments" TO "service_role";



GRANT ALL ON TABLE "public"."pre_restore_users_20250706" TO "anon";
GRANT ALL ON TABLE "public"."pre_restore_users_20250706" TO "authenticated";
GRANT ALL ON TABLE "public"."pre_restore_users_20250706" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_admin_view" TO "anon";
GRANT ALL ON TABLE "public"."purchase_admin_view" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_admin_view" TO "service_role";



GRANT ALL ON TABLE "public"."purchase_integrity_check" TO "anon";
GRANT ALL ON TABLE "public"."purchase_integrity_check" TO "authenticated";
GRANT ALL ON TABLE "public"."purchase_integrity_check" TO "service_role";



GRANT ALL ON TABLE "public"."referral_commissions" TO "anon";
GRANT ALL ON TABLE "public"."referral_commissions" TO "authenticated";
GRANT ALL ON TABLE "public"."referral_commissions" TO "service_role";



GRANT ALL ON TABLE "public"."referrals" TO "anon";
GRANT ALL ON TABLE "public"."referrals" TO "authenticated";
GRANT ALL ON TABLE "public"."referrals" TO "service_role";



GRANT ALL ON TABLE "public"."reward_questions" TO "anon";
GRANT ALL ON TABLE "public"."reward_questions" TO "authenticated";
GRANT ALL ON TABLE "public"."reward_questions" TO "service_role";



GRANT ALL ON TABLE "public"."system_config" TO "anon";
GRANT ALL ON TABLE "public"."system_config" TO "authenticated";
GRANT ALL ON TABLE "public"."system_config" TO "service_role";



GRANT ALL ON TABLE "public"."system_emails" TO "anon";
GRANT ALL ON TABLE "public"."system_emails" TO "authenticated";
GRANT ALL ON TABLE "public"."system_emails" TO "service_role";



GRANT ALL ON TABLE "public"."system_logs" TO "anon";
GRANT ALL ON TABLE "public"."system_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."system_logs" TO "service_role";



GRANT ALL ON TABLE "public"."system_settings" TO "anon";
GRANT ALL ON TABLE "public"."system_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."system_settings" TO "service_role";



GRANT ALL ON TABLE "public"."test_affiliate_reward" TO "anon";
GRANT ALL ON TABLE "public"."test_affiliate_reward" TO "authenticated";
GRANT ALL ON TABLE "public"."test_affiliate_reward" TO "service_role";



GRANT ALL ON SEQUENCE "public"."test_affiliate_reward_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."test_affiliate_reward_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."test_affiliate_reward_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."test_company_daily_profit" TO "anon";
GRANT ALL ON TABLE "public"."test_company_daily_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."test_company_daily_profit" TO "service_role";



GRANT ALL ON SEQUENCE "public"."test_company_daily_profit_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."test_company_daily_profit_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."test_company_daily_profit_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."test_daily_yield_log" TO "anon";
GRANT ALL ON TABLE "public"."test_daily_yield_log" TO "authenticated";
GRANT ALL ON TABLE "public"."test_daily_yield_log" TO "service_role";



GRANT ALL ON SEQUENCE "public"."test_daily_yield_log_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."test_daily_yield_log_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."test_daily_yield_log_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."test_user_daily_profit" TO "anon";
GRANT ALL ON TABLE "public"."test_user_daily_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."test_user_daily_profit" TO "service_role";



GRANT ALL ON SEQUENCE "public"."test_user_daily_profit_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."test_user_daily_profit_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."test_user_daily_profit_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."test_yield_summary" TO "anon";
GRANT ALL ON TABLE "public"."test_yield_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."test_yield_summary" TO "service_role";



GRANT ALL ON TABLE "public"."user_daily_profit" TO "anon";
GRANT ALL ON TABLE "public"."user_daily_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."user_daily_profit" TO "service_role";



GRANT ALL ON TABLE "public"."user_daily_profit_backup" TO "anon";
GRANT ALL ON TABLE "public"."user_daily_profit_backup" TO "authenticated";
GRANT ALL ON TABLE "public"."user_daily_profit_backup" TO "service_role";



GRANT ALL ON TABLE "public"."user_deletion_logs" TO "anon";
GRANT ALL ON TABLE "public"."user_deletion_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."user_deletion_logs" TO "service_role";



GRANT ALL ON TABLE "public"."user_monthly_rewards" TO "anon";
GRANT ALL ON TABLE "public"."user_monthly_rewards" TO "authenticated";
GRANT ALL ON TABLE "public"."user_monthly_rewards" TO "service_role";



GRANT ALL ON SEQUENCE "public"."user_monthly_rewards_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."user_monthly_rewards_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."user_monthly_rewards_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."user_referral_profit_summary" TO "anon";
GRANT ALL ON TABLE "public"."user_referral_profit_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."user_referral_profit_summary" TO "service_role";



GRANT ALL ON TABLE "public"."user_total_referral_profit" TO "anon";
GRANT ALL ON TABLE "public"."user_total_referral_profit" TO "authenticated";
GRANT ALL ON TABLE "public"."user_total_referral_profit" TO "service_role";



GRANT ALL ON TABLE "public"."user_withdrawal_settings" TO "anon";
GRANT ALL ON TABLE "public"."user_withdrawal_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."user_withdrawal_settings" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






